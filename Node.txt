https://github.com/dkhd/node-group-chat -> INTERESTING -> Build A Group-Chat App in 30 Lines Using Node.js
https://ejs.co/ -> Embedded Java Script homepage

Using BCrypt
You know it’s insecure to store plain-text passwords in the database. That would make it easy for someone to find the passwords for all users. One improvement you can make over plain text is to use encryption. Encryption is still a bad way to store passwords, though, since having the key would allow you to simply decrypt the passwords. Therefore, encryption is a totally insecure way to store passwords.

The secure way to deal with passwords is by using a hashing algorithm. A hash is a one-way algorithm. You store the hash result in the database, and then when checking a password, you hash it and compare the result with the hash stored in the database. There is no way to go from the hash back to the original password. Also, having the hash isn’t enough to get a password that matches it (at least without a rainbow table). So if somehow a hacker got a hash for a user’s password, they still couldn’t actually log in.
I won’t get into the specifics of the algorithm, but research the terms rainbow tables and password salting to learn more.
There are still problems with straight hashing like rainbow tables or brute-force attacks. The best solution today for dealing with passwords is BCrypt. BCrypt is a hashing algorithm that is intentionally slow, making brute-force attacks too expensive to do.
Like JWT, it’s not really important to understand how it works, just how to use it. To find the bcrypt hash of your pass password, you can calculate it inside a Node console:

$ npm install --save bcrypt
$ node
> require('bcrypt').hashSync('pass', 10)
'$2a$10$Jmo/n32ofSM9JvzfH0z6Me6TMyn6C/U9JhzDG8xhQC4ExHMG1jXz2'

The 10 is the number of rounds you want it to pass over to generate the hash. More rounds is more secure but slower (10 is sufficient for almost anything). Note that running it again results in a different hash. This is because it’s salted randomly. You can validate the password with compareSync:

> require('bcrypt').compareSync('pass', '$2a$10$Jmo/n32ofSM9JvzfH0z6Me6TMyn6C/U9JhzDG8xhQC4ExHMG1jXz2')
true

+++++++++++++++++++++++++++++++++++++++++
INTRO TO NODE
+++++
Installation
Node REPL
Running Node Files
Process
argv
File System Module

WHAT IS NODE	->	Javascript Runtime for Server side code
---
ECMAScript Specification for BROWSER to follow the rules and implement the Javascript language
Until recently we could only run Javascript code in a web browser. Node is a Javascript runtime that executes code outside of browser
NODE is an implementation of Javascript that runs outside of the browser.So we can run Javascript code without opening a browser

NODEJS vs CLIENT-SIDE JS
	NOT INCLUDED IN NODE
		Because Node doesn't run in a browser, we dont have access to all the browser "stuff" i.e. window, document, DOM API
	NEW STUFF IN NODE
		Built-in modules that help to interact with the OS and files/folders
	IN JAVASCRIPT - GLOBAL SCOPE IS 'window'. WHEREAS IN NODE, GLOBAL SCOPE IS 'global'

Use Cases of NODE
	WEB SERVERS
	COMMAND LINE TOOLS
	NATIVE APPS(VSCODE)
	VIDEO GAMES
	DRONE SOFTWARE

Unlike in the browser where the window is the global object(top level of everything, representing the browser window) where a
whole bunch of functions such as alerts are stored.
In case of node, instead of WINDOW, we call the global scope as GLOBAL itself

> global
<ref *1> Object [global] {
  global: [Circular *1],
  clearInterval: [Function: clearInterval],
  clearTimeout: [Function: clearTimeout],
  setInterval: [Function: setInterval],
  setTimeout: [Function: setTimeout] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  },
  queueMicrotask: [Function: queueMicrotask],
  performance: Performance {
    nodeTiming: PerformanceNodeTiming {
      name: 'node',
      entryType: 'node',
      startTime: 0,
      duration: 679328.010100007,
      nodeStart: 1.2558000087738037,
      v8Start: 22.136500000953674,
      bootstrapComplete: 69.0988000035286,
      environment: 41.915800005197525,
      loopStart: 121.5130999982357,
      loopExit: -1,
      idleTime: 679010.8446
    },
    timeOrigin: 1643042834169.897
  },
  clearImmediate: [Function: clearImmediate],
  setImmediate: [Function: setImmediate] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  }
}


> setTimeout(() => {console.log('displayed after 5 seconds')}, 5000);
Timeout {
  _idleTimeout: 5000,
  _idlePrev: [TimersList],
  _idleNext: [TimersList],
  _idleStart: 794652,
  _onTimeout: [Function (anonymous)],
  _timerArgs: undefined,
  _repeat: null,
  _destroyed: false,
  [Symbol(refed)]: true,
  [Symbol(kHasPrimitive)]: false,
  [Symbol(asyncId)]: 71,
  [Symbol(triggerId)]: 5
}
> displayed after 5 seconds


NODE REPL
---
REPL - Read Evaluate Print Loop
	REPL is continuing to just listen and wait for us to type something in, so that it can evaluate it

On the command prompt, enter node, we enter into the NODE equivalent of the Javascript console in chrome

PROCESS AND ARGV
---
NVM - NODE VERSION MANAGER

PROCESS - The process object is a "global" that provides information about, and control over, the current node.js process. As a global, it is always available to
node.js applications without using require(). It can also be explicitly accessed using require()

	const process = require('process');
	process.cwd()	-> Current Working Directory
	process.argv	->	The process.argv property returns an array containing the command-line arguments passed when the Node.js process was launched.
		process.argv.forEach((val, index) => {
			console.log(`${index}: ${val}`);
		});

		node argv.js one two=three four
			0: C:\Program Files\nodejs\node.exe		->	Node Executable
			1: C:\Users\vijayanand.s\Desktop\PLANNER2\LEARNING\WebDevelopment\Node\helloNode\argv.js	-> File that we are executing
			2: one		->	onwards are command line arguments
			3: two=three
			4: four

FILE SYSTEM MODULE
---
Unlike process, fs module is not available by default. we need to import it.
The fs module enables interacting with the file system in a way modeled on standard POSIX functions.
All file system operations have synchronous, callback, and promise-based forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).

ASYNC vs SYNCHRONOUS VERSION
The Synchronous version will block the entire process until they complete halting all connections

const fs = require('fs');

	//ASYNC
	fs.mkdir('myDir', { recursive: true }, (err) => {
		console.log('INSIDE MKDIR CALLBACK')
		if (err) throw err;
	});
	//SYNC
	fs.mkdirSync('myDirSync');
	console.log('AFTER MKDIR CALLBACK')

In case of ASYNC, Output will be
AFTER MKDIR CALLBACK
INSIDE MKDIR CALLBACK

---
const fs = require('fs');

// Creates /tmp/a/apple, regardless of whether `/tmp` and /tmp/a exist.
//ASYNC
fs.mkdir('myDirAsync', { recursive: true }, (err) => {
    console.log('INSIDE MKDIR CALLBACK')
    if (err) throw err;
});
try {
    //SYNC
    fs.mkdirSync('myDirSync');
    //USING ARGV
    const folderName = process.argv[2] || 'defaultFolder';
    fs.mkdirSync(folderName);
    fs.writeFileSync(`${folderName}/index.html`, "Hello");
    fs.writeFileSync(`${folderName}/app.js`, "Hello");
    fs.writeFileSync(`${folderName}/app.css`, "Hello");
    console.log('AFTER MKDIR CALLBACK')
} catch (e) {
    console.log('SOMETHING WENT WRONG');
    console.log(e);
}

+++++++++++++++++++++++++++++++++++++++++
MODULES & NPM
+++++
Module.Exports
Requiring Modules
Using NPM
Installing Packages
Creating Package.json files
The Dad jokes package
Rainbow package
Figlet package
Franc package

MODULE.EXPORTS
---
Write reusable pieces that we can import and use in our own applications
unless the reusable library is NOT EXPORTed, we cannot reuse that functionality using REQUIRE

math.js
	const add = (x, y) => x + y;
	const PI = 3.14159;
	const square = x => x * x;
	module.exports = "HELLO!"
app.js
	const math = require('./math');
	console.log(math);

node app.js	-> This will print "HELLO!"

math.js	-> contents of module.exports should be an object, where we are adding properties onto
	module.exports.add = add
	module.exports.PI = PI
	module.exports.square = square

node app.js	-> Now we have access to entire math object
{ add: [Function: add], PI: 3.14159, square: [Function: square] }

EXPORTS -> shorter syntax
	The exports variable is available within a module's file level scope, and is assigned the
	value of module.exports before the module is evaulated. It allows a shortcut, so that
	module.exports.f = ... can be written more succintly as exports.f = ...
	NOTE: Do not use exports as your variable name

MATH.JS
	const add = (x, y) => x + y;
	const PI = 3.14159;
	const square = x => x * x;

	//SOLUTION #1
	//The contents of module.exports is usually an object
	//module.exports = "HELLO!"

	//SOLUTION #2
	//module.exports.add = add
	//module.exports.PI = PI
	//module.exports.square = square

	//SOLUTION #3
	//const math = {
	//    PI: PI,
	//    add: add,
	//    square: square
	//};
	//module.exports = math

	//SOLUTION #4
	//module.exports.add = (x, y) => x + y;
	//module.exports.PI = 3.14159;
	//module.exports.square = x => x * x;

	//SOLUTION #5
	exports.add = (x, y) => x + y;
	exports.PI = 3.14159;
	exports.square = x => x * x;

APP.JS
	const math = require('./math');
	//we can also destructure modules as follows
	const { PI, add, square } = require('./math');

	console.log(math);

	console.log(math.PI);
	console.log(math.add(3, 2));
	console.log(math.square(9));

	//using destructured modules
	console.log(PI);
	console.log(add(3, 2));
	console.log(square(9));

REQUIRING A DIRECTORY -> using index.js
---
We can actually require an entire directory. Whatever the file index.js exports is what we get when we require an entire directory


red.js
	module.exports.red = {
		type: 'color',
		name: 'red'
	}

green.js
	module.exports.green = {
		type: 'color',
		name: 'green'
	}
blue.js
	module.exports.blue = {
		type: 'color',
		name: 'blue'
	}
index.js
	const red = require('./red');
	const green = require('./green');
	const blue = require('./blue');

	const allColors = [red, green, blue]

	module.exports = allColors;
app.js
	const mydir = require('./mydir');
	console.log(mydir);

OUTPUT
[
  { red: { type: 'color', name: 'red' } },
  { green: { type: 'color', name: 'green' } },
  { blue: { type: 'color', name: 'blue' } }
]

NPM(NODE PACKAGE MANAGER)
---
NPM is really 2 things:
	1) A library of thousands of packages published by other developers that we can use for free
	2) A command line tool to easily install and manage those packages in our Node projects

> npm
npm <command>

Usage:

npm install        install all the dependencies in your project
npm install <foo>  add the <foo> dependency to your project
npm test           run this project's tests
npm run <foo>      run the script named <foo>
npm <command> -h   quick help on <command>
npm -l             display usage info for all commands
npm help <term>    search for help on <term> (in a browser)
npm help npm       more involved overview (in a browser)

All commands:

    access, adduser, audit, bin, bugs, cache, ci, completion,
    config, dedupe, deprecate, diff, dist-tag, docs, doctor,
    edit, exec, explain, explore, find-dupes, fund, get, help,
    hook, init, install, install-ci-test, install-test, link,
    ll, login, logout, ls, org, outdated, owner, pack, ping,
    pkg, prefix, profile, prune, publish, rebuild, repo,
    restart, root, run-script, search, set, set-script,
    shrinkwrap, star, stars, start, stop, team, test, token,
    uninstall, unpublish, unstar, update, version, view, whoami

Specify configs in the ini-formatted file:
    C:\Users\vijayanand.s\.npmrc
or on the command line via: npm <command> --key=value

More configuration info: npm help config
Configuration fields: npm help 7 config

npm@8.1.2 C:\Program Files\nodejs\node_modules\npm

INSTALLING PACKAGES - JOKES AND RAINBOW
---
npm install <packagename>
npm i - alias for npm install
node_modules - running the command will create a folder called NODE_MODULES. Under that folder we can see lot of dependencies for that one module
package_lock.json - is a record for contents of node module

ADDING GLOBAL PACKAGES	-> adds to the global node_modules directory
---
npm i -g cowsay		-> g is for global
USAGE
cowsay vijay anand
 _____________
< vijay anand >
 -------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

NOTE: Generally we want to install locally using "npm install" command. In case you have installed globally and want to refer in
node source code, you need to additionally apply "npm link <package>" command.

PACKAGE.JSON
---
We will put this file inside every node module that we create. It's not mandatory. But we will want it there as a best practice
This is a very special file in NPM/NODE world that includes metadata about your project/package
We typically keep this in the ROOT directory of our project
If we have a package.json and if we install dependencies, those dependencies will automatically be added to the DEPENDENCY section of package.json
This is useful for 2 reasons
	1) Keeping a record of what we are using
	2) For sharing this file with other people on a different machine, where we can actually go and download these dependencies

npm init -> Using this creation utility command, an easy way to make package.json which will be filled out with whatever answers you enter
		PS C:\Users\vijayanand.s\Desktop\PLANNER2\LEARNING\WebDevelopment\Node\helloPackageJson> npm init
		This utility will walk you through creating a package.json file.
		It only covers the most common items, and tries to guess sensible defaults.

		See `npm help init` for definitive documentation on these fields
		and exactly what they do.

		Use `npm install <pkg>` afterwards to install a package and
		save it as a dependency in the package.json file.

		Press ^C at any time to quit.
		package name: (hellopackagejson)
		version: (1.0.0)
		description:
		entry point: (index.js)
		test command:
		git repository:
		keywords:
		author:
		license: (ISC)
		About to write to C:\Users\vijayanand.s\Desktop\WebDevelopment\Node\helloPackageJson\package.json:

		{
		  "name": "hellopackagejson",
		  "version": "1.0.0",
		  "description": "",
		  "main": "index.js",
		  "scripts": {
			"test": "echo \"Error: no test specified\" && exit 1"
		  },
		  "author": "",
		  "license": "ISC"
		}


		Is this OK? (yes) yes

----
NOTE: npm init -y	-> THIS WILL SKIP ALL THOSE QUESTIONS


For Example
package.json
		{
		  "name": "hellopackagejson",
		  "version": "1.0.0",
		  "description": "",
		  "main": "index.js",
		  "scripts": {
			"test": "echo \"Error: no test specified\" && exit 1"
		  },
		  "author": "",
		  "license": "ISC",
		  "dependencies": {
			"colors": "^1.4.0",
			"figlet": "^1.5.2"
		  }
		}

index.js
		const figlet = require('figlet')
		const colors = require('colors')

		figlet('Hello World!!', function (err, data) {
			if (err) {
				console.log('Something went wrong...');
				console.dir(err);
				return;
			}
			console.log(data.america)
		});

INSTALLING PROJECT DEPENDENCIES
---
Dependencies could take up a lot of space
Generally we do not share node_modules with anybody
simply invoke the command "npm install" and it will lookup package.json and will install all dependencies

++++++++++++++++++++++++++++++++++++++++
CREATING SERVERS WITH EXPRESS
++++++++++++++++
EXPRESS IS A FRAMEWORK FOR WEB DEVELOPMENT FOR CREATING SERVERS USING NODE
What are frameworks?
Our first express app
Routing Basics
Path Parameters
Working with Query Strings
Nodemon

EXPRESS
---
Express is a "Fast, unopinionated, minimalistic web framework for node js" It helps us build web apps
Its just an NPM package which comes with a bunch of methods and optional plugins that we can use to build web applications and APIs
Express helps us
	Start up a server to listen for requests
	Parse incoming requests
	Match those requests to particular routes
	Craft our HTTP response and associated content

LIBRARY vs FRAMEWORK
	When you use a library, you are in charge. You control the flow of your application code, and you decide when to use the library
		- example Bootstrap, Axios
With Framwork, the control is inverted. The framework is in charge, and you are merely a participant. The framework tells you where
to plug in the code

npm install express

index.js
	const express = require('express');
	const app = express();
	console.dir(app);

node index.js
	<ref *1> [Function: app] {
	  _events: [Object: null prototype] { mount: [Function: onmount] },
	  _eventsCount: 1,
	  _maxListeners: undefined,
	  setMaxListeners: [Function: setMaxListeners],
	  getMaxListeners: [Function: getMaxListeners],
	  emit: [Function: emit],
	  addListener: [Function: addListener],
	  on: [Function: addListener],
	  prependListener: [Function: prependListener],
	  once: [Function: once],
	  prependOnceListener: [Function: prependOnceListener],
	  removeListener: [Function: removeListener],
	  off: [Function: removeListener],
	  removeAllListeners: [Function: removeAllListeners],
	  listeners: [Function: listeners],
	  rawListeners: [Function: rawListeners],
	  listenerCount: [Function: listenerCount],
	  eventNames: [Function: eventNames],
	  init: [Function: init],
	  defaultConfiguration: [Function: defaultConfiguration],
	  lazyrouter: [Function: lazyrouter],
	  handle: [Function: handle],
	  use: [Function: use],
	  route: [Function: route],
	  engine: [Function: engine],
	  param: [Function: param],
	  set: [Function: set],
	  path: [Function: path],
	  enabled: [Function: enabled],
	  disabled: [Function: disabled],
	  enable: [Function: enable],
	  disable: [Function: disable],
	  acl: [Function (anonymous)],
	  bind: [Function (anonymous)],
	  checkout: [Function (anonymous)],
	  connect: [Function (anonymous)],
	  copy: [Function (anonymous)],
	  delete: [Function (anonymous)],
	  get: [Function (anonymous)],
	  head: [Function (anonymous)],
	  link: [Function (anonymous)],
	  lock: [Function (anonymous)],
	  'm-search': [Function (anonymous)],
	  merge: [Function (anonymous)],
	  mkactivity: [Function (anonymous)],
	  mkcalendar: [Function (anonymous)],
	  mkcol: [Function (anonymous)],
	  move: [Function (anonymous)],
	  notify: [Function (anonymous)],
	  options: [Function (anonymous)],
	  patch: [Function (anonymous)],
	  post: [Function (anonymous)],
	  propfind: [Function (anonymous)],
	  proppatch: [Function (anonymous)],
	  purge: [Function (anonymous)],
	  put: [Function (anonymous)],
	  rebind: [Function (anonymous)],
	  report: [Function (anonymous)],
	  search: [Function (anonymous)],
	  source: [Function (anonymous)],
	  subscribe: [Function (anonymous)],
	  trace: [Function (anonymous)],
	  unbind: [Function (anonymous)],
	  unlink: [Function (anonymous)],
	  unlock: [Function (anonymous)],
	  unsubscribe: [Function (anonymous)],
	  all: [Function: all],
	  del: [Function (anonymous)],
	  render: [Function: render],
	  listen: [Function: listen],
	  request: IncomingMessage { app: [Circular *1] },
	  response: ServerResponse { app: [Circular *1] },
	  cache: {},
	  engines: {},
	  settings: {
		'x-powered-by': true,
		etag: 'weak',
		'etag fn': [Function: generateETag],
		env: 'development',
		'query parser': 'extended',
		'query parser fn': [Function: parseExtendedQueryString],
		'subdomain offset': 2,
		'trust proxy': false,
		'trust proxy fn': [Function: trustNone],
		view: [Function: View],
		views: 'C:\\Users\\vijayanand.s\\WebDevelopment\\Node\\helloExpress\\views',
		'jsonp callback name': 'callback'
	  },
	  locals: [Object: null prototype] {
		settings: {
		  'x-powered-by': true,
		  etag: 'weak',
		  'etag fn': [Function: generateETag],
		  env: 'development',
		  'query parser': 'extended',
		  'query parser fn': [Function: parseExtendedQueryString],
		  'subdomain offset': 2,
		  'trust proxy': false,
		  'trust proxy fn': [Function: trustNone],
		  view: [Function: View],
		  views: 'C:\\Users\\vijayanand.s\\WebDevelopment\\Node\\helloExpress\\views',
		  'jsonp callback name': 'callback'
		}
	  },
	  mountpath: '/'
	}
---
This app starts a server and listens on port 3000 for connections. The app responds with “Hello World!” for requests to the root URL (/) or route.
For every other path, it will respond with a 404 Not Found.

const express = require('express');
const app = express();
console.dir(app);
const port = 3000

app.get('/', (req, res) => {
    res.send('Hello World!')
})

app.listen(port, () => {
    console.log(`Example app listening on port ${port}`)
})

REQUEST AND RESPONSE OBJECTS
---
On every incoming requests, we have access to 2 different parameters in this function that are automatically passed in
REQUEST and RESPONSE
These are objects made by Express and passed in to this callback
The req object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on.

Request
Properties
	req.app
	req.baseUrl
	req.body
	req.cookies
	req.fresh
	req.host
	req.hostname
	req.ip
	req.ips
	req.method
	req.originalUrl
	req.params
	req.path
	req.protocol
	req.query
	req.route
	req.secure
	req.signedCookies
	req.stale
	req.subdomains
	req.xhr
Methods
	req.accepts()
	req.acceptsCharsets()
	req.acceptsEncodings()
	req.acceptsLanguages()
	req.get()
	req.is()
	req.param()
	req.range()

Response
Properties
	res.app
	res.headersSent
	res.locals
Methods
	res.append()
	res.attachment()
	res.cookie()
	res.clearCookie()
	res.download()
	res.end()
	res.format()
	res.get()
	res.json()
	res.jsonp()
	res.links()
	res.location()
	res.redirect()
	res.render()
	res.send()
	res.sendFile()
	res.sendStatus()
	res.set()
	res.status()
	res.type()
	res.vary()

res.send([body]) -> Sends the HTTP response.
	res.send(Buffer.from('whoop'))
	res.send({ some: 'json' })
	res.send('<p>some html</p>')
	res.status(404).send('Sorry, we cannot find that!')
	res.status(500).send({ error: 'something blew up' })
---
app.use((req, res) => {
    //res.send('SENDING RESPONSE AS STRING');
    //res.send('<h1>SENDING RESPONSE AS HTML<h1>');
    res.send({ some: 'SENDING RESPONSE AS JAVASCRIPT OBJECT' });
})

EXPRESS ROUTING BASICS
---
Routing refers to taking incoming requests and a path that is requested and matching that to some code in some response.

app.get('/', (req, res) => {
    res.send('WELCOME HOME!')
})

app.get('/dogs', (req, res) => {
    res.send('DOGS SAY WOOF!')
})

app.get('/cats', (req, res) => {
    res.send('CATS SAY MEOW!')
})

app.get('*', (req, res) => {
    res.send('I DONT KNOW THAT PATH')
})

Note: this code only runs when an incoming request is exactly asking for cats and nothing else.

EXPRESS PATH PARAMETERS
---
NOTE #1
Rather than hardcoding each route, we define a generic pattern and the pattern would be something like the following
	/section/:subsection	-> where subsection could be a variable or a pattern
creating our route where inside of the path string we actually use a colon to designate something as a variable or as a path variable.
	app.get('/section/:subsection')
define a pattern as /section and then Colon separate it.

//subsection could be anything
//for example, http://localhost:3000/section/whatever
app.get('/section/:subsection', (req, res) => {
    res.send('WELCOME TO SUBSECTION!')
})

So this will match the actual string section, but it will also match anything that follows this pattern.

NOTE #2
I may also need access to what that subsection is. Express adds a "params" property to the request object.
We can extract that from params

//for example, http://localhost:3000/section/whatever
app.get('/section/:subsection', (req, res) => {
    const params = req.params;
    console.log(params);
    res.send(`WELCOME TO ${params.subsection} SUBSECTION!`)
})

This returns ->
	{ subsection: 'whatever' }
	WELCOME TO whatever SUBSECTION!

app.get('/section/:subsection/x/y/z/:nestedsection', (req, res) => {
    const params = req.params;
    console.log(params);
    const { subsection, nestedsection } = req.params;
    res.send(`WELCOME TO ${nestedsection} OF ${subsection} SUBSECTION!`)
})

This returns ->
	{ subsection: 'whatever', nestedsection: 'deepunder' }
	WELCOME TO deepunder OF whatever SUBSECTION!

WORKING WITH QUERY STRINGS
---
The request object has a particular property called Query, having key value pairs made or based upon the query string.

//for example, http://localhost:3000/search?name=vijay&color=blue
app.get('/search', (req, res) => {
    console.dir(req.query);
    const { name, color } = req.query;
    res.send(`THE NAME IS ${name} AND COLOR IS ${color}`)
})

This returns ->
THE NAME IS vijay AND COLOR IS blue

AUTO-RESTART WITH NODEMON	-> replace node with nodemon
---
By default, we have to restart our server any time we change our code
However, there is a nice way of basically automatically restarting the server whenever we change our code base.
install NODEMON globally. It is a command line tool, we basically just will run NODEMON and then our file instead of NODE
and it will watch for changes of our files and then it'll restart the server whenever necessary, whenever it detects changes.

npm i -g nodemon
nodemon .\index.js

Example app listening on port 3000
[nodemon] restarting due to changes...
[nodemon] starting `node .\index.js`

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CREATING DYNAMIC HTML WITH TEMPLATING
++++++++++++++++++++++++++
What is Templating?
Configuring express for EJS
Passing data to templates
EJS loops and Conditionals
Serving static assets
Creating partials

WHAT IS TEMPLATING?
---
Templating allows us to define a preset pattern for a web page, that we can dynamically modify
For example, we could define a single "search" template that displays all the results for a given search term
We dont know what the term is (or) how many results there are ahead of time
The webpage is created on the fly

EJS - Embedded Javascript Templating - Uses Javascript Syntax
Handlebar
Jade
Pug
Nunjucks

CONFIGURING EXPRESS FOR EJS
---
When it's time to render ejs template, express takes our template and it's going to evaluate it in any places where it sees JavaScript.
It will run the Javascript and will spit out HTML

app.set('view engine','ejs');
npm i ejs
We dont need to require in this file. Instead by setting the view engine = ejs, express will require the package behind the scenes
Also by default, when we create a new express app and we're using some view engine, Express is going to assume that our views templates
exist in a directory called "views".
Instead of res.send, if you want to return a HTML, use res.render()

using app.set(name, value) -> Assigns setting name to value.

VIEWS ->
	String or Array.
	A directory or an array of directories for the application's views.
	If an array, the views are looked up in the order they occur in the array.
	process.cwd() + '/views'

RENDER
	res.render(view [, locals] [, callback])
	Renders a view and sends the rendered HTML string to the client. Optional parameters:
		locals, an object whose properties define local variables for the view.
		callback, a callback function. If provided, the method returns both the possible error and rendered string, but does not perform an automated response.
		When an error occurs, the method invokes next(err) internally.
	NOTE:
	The view argument is a string that is the file path of the view file to render.
	This can be an absolute path, or a path relative to the views setting.
	If the path does not contain a file extension, then the view engine setting determines the file extension.
	If the path does contain a file extension, then Express will load the module for the specified template engine
		(via require()) and render it using the loaded module’s __express function.

SETTING THE VIEWS DIRECTORY
---
The default "views" directory that Express is looking for is only going to work if I am running my application
from within the same directory where my "views" folder is.

i.e node index.js -> will work fine for default "views"
    node someDir/index.js -> will NOT work fine for default "views"
	It will throw error as follows:
	Error: Failed to lookup view "home" in views directory "C:\Users\vijayanand.s\WebDevelopment\Node\views"

If we want the index.js to be run from anywhere, we need to change the "views" directory
	i.e the directory where index.js is located, slash views

	app.set('views', path.join(__dirname, 'templateViews'));
	WebDevelopment\Node> nodemon .\viewsDirTemplates\index.js

process.cwd() -> Refers to the current working directory
"path" module provides utilities for working with file and directory paths
path.join - joins all given path segments together using the platform-specific separator as delimiter, then normalizesthe resulting path
__dirname - double underscore dirname refer to the directory where the current file is located. Similar to dot(.) in linux

INDEX.JS
	const express = require('express');
	const path = require('path');
	const app = express();
	const port = 3000
	//By default the templates will be available in views folder. Also.ejs extension not needed
	app.set('view engine', 'ejs');
	//If we want the index.js to be run from anywhere, we need to change the "views" directory
	//i.e the directory where index.js is located, slash views. It can be custom name too i.e templateViews
	app.set('views', path.join(__dirname, 'templateViews'));

	app.get('/', (req, res) => {
		//res.render('views/home.ejs');
		res.render('home');
	})

	app.listen(port, () => {
		console.log("Listening on port 3000");
	})

EJS INTERPOLATION SYNTAX
---
interpolating data - fill in the blanks

For example
	<h1>Hello from <%= 2+3> home!</h1>

EJS TAGS
	<% 'Scriptlet' tag, for control-flow, no output
	<%_ ‘Whitespace Slurping’ Scriptlet tag, strips all whitespace before it
	<%= Outputs the value into the template (HTML escaped)
	<%- Outputs the unescaped value into the template
	<%# Comment tag, no execution, no output
	<%% Outputs a literal '<%'
	%> Plain ending tag
	-%> Trim-mode ('newline slurp') tag, trims following newline
	_%> ‘Whitespace Slurping’ ending tag, removes all whitespace after it

PASSING DATA TO TEMPLATES
---
INDEX.JS
	app.get('/random', (req, res) => {
		//res.render('views/random.ejs');
		const randFromNode = Math.floor(Math.random() * 10) + 1;
		//res.render('random', { randFromNode: randFromNode });
		//If both key and value are same, we can combine into one
		res.render('random', { randFromNode });
	})

RANDOM.EJS
	<h1>The random number from Node is <%=randFromNode%>

SUBSECTION DATA PASSING
---
INDEX.JS
	app.get('/section/:subsection/x/y/z/:nestedsection', (req, res) => {
		const params = req.params;
		const { subsection, nestedsection } = req.params;
		res.render('random', { subsection, nestedsection });
	})

RANDOM.EJS
	<h1>WELCOME TO <%=nestedsection%> OF <%=subsection%> SUBSECTION!</h1>

CONDITIONALS IN EJS
---
<% %> - Get rid of the equals sign that will allow us to embed Javascript without the result actually being added into the template

    <h3>
        <% if(randFromNode%2===0) {%>
            The random number from Node is EVEN
            <%}else{%>
                The random number from Node is ODD
                <%}%>
    </h3>
    <h3>
        The random number from Node is <%= randFromNode%2===0?'EVEN':'ODD' %>
    </h3>

LOOPS IN EJS
---
INDEX.JS
	const family = ['vijay', 'priya', 'gautham', 'meenu', 'nimi', 'selva'];
	res.render('random', { family });
RANDOM.JS
    <h3>Family Members are:</h3>
    <ul>
        <%for(let member of family){%>
            <li>
                <%=member%>
            </li>
            <%}%>

    </ul>

EXAMPLE ON LOOPS & CONDITIONALS
---
INDEX.JS
	const express = require('express');
	const data = require('./data.json');
	const app = express();
	const port = 3000
	app.set('view engine', 'ejs');

	app.get('/section/:subsection', (req, res) => {
		const { subsection } = req.params;
		const subsectionData = data[subsection]
		res.render('home', { ...subsectionData });//triple dots mean spread
	})


	app.listen(port, () => {
		console.log("Listening on port 3000");
	})
HOME.JS
	<body>
		<p>Name:<%=name%>
		</p>
		<p>Subscribers:<%=subscribers%>
		</p>
		<p>Description:<%=description%>
		</p>
		<ul>
			<%for(let post of posts){%>
				<li><b>Title</b> : <%=post.title%> - <b>Author</b> : <%=post.author%></li>
				<%if(post.img){%>
					<li><img src="<%=post.img%>" alt="" height="100px" width="100px"></li>
				 <%}%>
			<%}%>
		</ul>
	</body>

SERVING STATIC FILES ON EXPRESS
---
EXPRESS.STATIC -> MIDDLEWARE
To serve static files such as images, CSS, Javascript, font, images and logo use the express.static built-in middleware function on express. The function signature is
	express.static(root[,options])

app.use(express.static('public'))
	Middleware that executes on every single time we have any request
	Its not a route. Doesn't care about the path, GET or POST request
	That runs in between requests and response
	Pass in the argument of the folder that we want to serve our assets from i.e public directory will be in the root dir of our application

NOTE: For best results, use a reverse proxy cache to improve performance of serving static assets.

Now, you can load the files that are in the public directory:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html

To use multiple static assets directories, call the express.static middleware function multiple times:

app.use(express.static('public'))
app.use(express.static('files'))
Express looks up the files in the order in which you set the static directories with the express.static middleware function.

NOTE: For best results, use a reverse proxy cache to improve performance of serving static assets.

INDEX.JS
	//To serve static files such as images, CSS, Javascript, font, images and logo
	app.use(express.static(path.join(__dirname, 'public')));
	//directory for EJS templates. Everything inside public directory will be accessible in EJS templates
	app.set('views', path.join(__dirname, 'views'));

PARTIALS( USING INCLUDES)
---
Way of including sub templates in other templates
Common code that is duplicated can be consolidated into header, footer etc

Includes are relative to the template with INCLUDE call(This requires the filename option). For example, if you have
./views/users.ejs and ./views/user/show.ejs, you would use <%- include('user/show');%>

The DASH means "Outputs the unescaped value into the template. Escaping means we are basically treating it as a string"
In Short
	EQUALS - Wont treat it as HTML
	DASH - Treats it as HTML

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DEFINING RESTFUL ROUTES
++++++++++++++++++

GET vs POST requests
Parsing request body
Method Override
RESTful routing
Hnadling post requests in Express
Forms + Express

GET vs POST
---
GET
used to retrieve information
Data is sent via. Query String
Information is plainly visible in the URL
Limited amount of data can be sent

POST
Used to post data to the server
Used to write/create/update
Data is sent via request body, not a query string
Can send any form of data(JSON)

DEFINING EXPRESS POST ROUTES
---
INDEX.JS
	const express = require('express');
	const app = new express();

	app.get('/tacos', (req, res) => {
		res.send('GET request invoked')
	});

	app.post('/tacos', (req, res) => {
		res.send('POST request invoked')
	});

	app.listen(3000, () => {
		console.log('Listening on port 3000');
	});

PARSING THE REQUEST BODY
---
req.body
	Contains key value pairs of data submitted in the request body
	By default, it is undefined, and is populated when you use body-parsing middleware such as express.json() or express.urlencoded()

Express needs to know how to treat them and understand what that information is in the body

INDEX.JS
	const express = require('express');
	const app = new express();

	app.use(express.json())								//for parsing application/json
	app.use(express.urlencoded({ extended: true }))		//for parsing application/x-www-form-urlencoded

	app.get('/tacos', (req, res) => {
		res.send('GET request invoked')
	});

	app.post('/tacos', (req, res) => {
		//This will print as undefined unless you define app.use(express.json())
		console.log(req.body)
		res.send('POST request invoked')
	});

	app.listen(3000, () => {
		console.log('Listening on port 3000');
	});

This will print
	{ name: 'vijay', age: '40' }
We can also destructure the JSON to extract the contents

INTRO TO REST
---
REST - Representational State Transfer
REST is an architectural style for distributed hypermedia systems
Its basically a set of guidelines for how a client+server should communicate and perform CRUD operations on a given resource
RESTful system compiles with these rules of REST

The main idea of REST is treating data on the server side as resources that can be CRUDed
The most common way of approaching REST is in formatting the URLs and HTTP verbs in your application.
RESOURCE - An entity that we are going to expose or provide access to via HTTP
Every RESTful system has a uniform interface consisting of URL pattern matched with different HTTP verbs to expose full CRUD operations over HTTP
Client Server architecture - Seperation of concerns
Statelessness - Doesnt remember previous requests
GET - Read
POST - Create
PATCH - Update
DELETE - Delete

EXAMPLE : USING COMMMENTS AS RESOURCE
Index - GET /comments - List all comments
New - GET /comments/new - FORM to create a new comment
Create - POST /comments - Create a new comment
Show - GET /comments/:id - Get one comment(using id)
Edit - GET /comments/:id/edit - FORM to edit specific comment(using id)
Update - PATCH /comments/:id - Update one comment(using id)
Destroy - DELETE /comments/:id - Delete one comment(using id)

EXPRESS REDIRECTS
---
Problem: When we refresh a page on a post request, we get "Confirm form resubmission", which is problematic as it sends duplicate post requests
IT RESUBMITS THE FORM AGAIN!

SOLUTION: instead of rendering something from the POST route, we are going to redirect the user somewhere

Redirects to the URL derived from the specified path, with specified status, a positive integer that corresponds to a HTTP Status Code.
If not specified, status defaults to "302 Found"

NOTE: REDIRECT DEFAULT=302. ALL REDIRECT STATUS CODES STARTS WITH 3..

res.redirect('/foo/bar')
res.redirect('http://example.com')
res.redirect(301,'http://example.com')
res.redirect('../login')

UUID PACKAGE
---
Creating a random UUID
For creation of RFC4122 UUID
Cryptographically strong random values
const {v4: uuid} = require('uuid');
uuidv4();

REST UPDATE
---
Difference between PUT and REST
	PUT requests completely updates an entire thing i.e. Replaces all current representation of the target resource with the request payload
	PATCH requests is used to apply partial modification to the resource

EXPRESS METHOD OVERRIDE
---
PROBLEM : HTML forms in our browser can only send GET/POST requests
			They cannot send a PUT/PATCH/DELETE request

npm install method-override
Lets us use HTTP verbs such as PUT or DELETE in places where the client doesn't support it(like a browser form)
Even though it is a POST request from the form, express is going to treat it as a PATCH request

EXAMPLE
---
INDEX.JS
	const express = require('express');
	const path = require('path');
	const { v4: myUUID } = require('uuid');
	var methodOverride = require('method-override');
	const app = new express();
	app.set('view engine', 'ejs');
	const port = 3000


	app.use(express.json())//for parsing application/json
	app.use(express.urlencoded({ extended: true }))
	app.set('views', path.join(__dirname, 'views'));
	//Even though it is a POST request from the form, express is going to treat it as a PATCH request
	//Override with POST having ?_method=PATCH
	app.use(methodOverride('_method'));

	let comments = [
		{
			id: myUUID(),
			user: 'Vijay',
			text: 'Hello, Howdy?'
		},
		{
			id: myUUID(),
			user: 'Priya',
			text: 'Hi, Im fine'
		}

	];

	//Index - GET /comments - List all comments
	app.get('/comments', (req, res) => {
		res.render('comments/index', { comments });
	});

	//New - GET /comments/new - FORM to create a new comment
	app.get('/comments/new', (req, res) => {
		res.render('comments/new');
	});

	//Create - POST /comments - Create a new comment
	app.post('/comments', (req, res) => {
		const { user, text } = req.body;
		console.log(req.body);
		comments.push({ user, text, id: myUUID() });
		res.redirect('/comments');//by default, it is GET request
	});

	//Show - GET /comments/:id - Get one comment(using id)
	app.get('/comments/:id', (req, res) => {
		const { id } = req.params;
		const comment = comments.find(c => c.id === id);
		res.render(`comments/show`, { comment });
	});

	//Edit - GET /comments/:id/edit - FORM to edit specific comment(using id)
	app.get('/comments/:id/edit', (req, res) => {
		const { id } = req.params;
		const comment = comments.find(c => c.id === id);
		res.render(`comments/edit`, { comment });
	});

	//Update - PATCH /comments/:id - Update one comment(using id)
	app.patch('/comments/:id', (req, res) => {
		const { id } = req.params;
		const newCommentText = req.body.text;
		const currentComment = comments.find(c => c.id === id);
		currentComment.text = newCommentText
		res.render(`comments`, { comments });
	});

	//Destroy - DELETE / comments /: id - Delete one comment(using id)
	app.delete('/comments/:id', (req, res) => {
		const { id } = req.params;
		const filteredComments = comments.filter(c => c.id !== id);
		comments = filteredComments;
		res.render(`comments`, { comments });
	});

	app.get('/tacos', (req, res) => {
		res.send('GET request invoked')
	});

	app.post('/tacos', (req, res) => {
		//This will print as undefined unless you define app.use(express.json())
		console.log(req.body)
		res.send('POST request invoked')
	});

	app.listen(port, () => {
		console.log('Listening on port 3000');
	});

INDEX.EJS
---
	<body>
		<h1>Comments:</h1>
		<ul>
			<%for(let comment of comments){%>
				<li>
					<b>
						<%=comment.user%>
					</b> - <%=comment.text%>
						<a href="/comments/<%=comment.id%>">more</a>
				</li>
				<%}%>
		</ul>
		<br>
		<a href="/comments/new">Create new comment</a>
	</body>

SHOW.EJS
---
	<body>
		<h1>Comment Id: <%=comment.id%>
		</h1>
		<article>
			<b>
				<%=comment.user%>
			</b> - <%=comment.text%>
		</article>
		<a href="/comments">View Comments</a>
		<a href="/comments/<%=comment.id%>/edit">Edit</a>
		<form method="POST" action="/comments/<%=comment.id%>?_method=DELETE">
			<button>Delete</button>
		</form>
	</body>

NEW.EJS
---
	<body>
		<form action="/comments" method="post">
			<section>
				<label for="username">Name: </label>
				<input id="username" type="text" placeholder="user name" name="user">
			</section>
			<br>
			<section>
				<label for="comment">Comment: </label>
				<textarea id="comment" name="text" placeholder="comments" cols="30" rows="2"></textarea>
			</section>
			<button type="submit">Post</button>
		</form>
		<a href="/comments">View Comments</a>
	</body>

EDIT.EJS
---
	<body>
		<!--Even though it is a POST request from the form, express is going to treat it as a DELETE request-->
		<form action="/comments/<%=comment.id%>?_method=PATCH" method="post">
			<section>
				<label for="comment">Comment: </label>
				<textarea id="comment" name="text" placeholder="comments" cols="30" rows="2"><%=comment.text%></textarea>
			</section>
			<button type="submit">Save</button>
		</form>
	</body>

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
OUR FIRST DATABASE - MONGO DB
+++++++++++++++++++++++++
Databases Basics
SQL vs NOSQL
Installation
Mongo Shell
Mongo Inserts
Mongo Updates
Mongo Deletes
Mongo Querying/Finding

DATABASE BASICS
---
Mongo is a document database, which we can use to store and retrieve complex data from
It is commonly used in combination with Node

SQL vs NOSQL
---
SQL are relational DB. We pre-define a schema of tables before we insert anything
	MySQL, Postgres, SQLite, Oracle, Microsoft SQL server
NOSql databases do not use SQL. There are many types of NOSql databases including document, key-value and graph stores
	MongoDB, CouchDB, Neo4j, Cassandra, Redis

WHY MONGO?
---
Mongo is very commonly used with Node and Express(MERN/MEAN stack)
It plays particularly well with Javascript

MONGO SHELL
---
Actually a javascript shell
	> "hello".toUpperCase()
	HELLO

Create new databases
change security or adminstrative permissions

>show dbs	-> list all databases
> use animalShelter			-> create a new database
switched to db animalShelter

> db						-> It says i'm inside of animalShelter db
animalShelter

> show collections			-> Lists all the collections. A collection is a container for similar data


BSON vs JSON
---
JSON - Text based. Not easy to compress. Doesn't support whole lot of datatypes i.e. String, Boolean, Number, Array
BSON - Binary JSON - More compact version of JSON. Mongo stores it as binary i.e. Supports String, Boolean, Number, Integer, Float, Long, Decimal, Array, Date, Raw Binary

MONGO INSERT
---
A Collection is a grouping of data in database
We insert different pieces of data into Collections
NOTE: If we insert something into a collection that doesnt exist, that collection will be made for us

db.collection.insertOne()	->	Inserts a single document into a collection
db.collection.insertMany()	->	Inserts multiple documents into a collection. Expects an array to be passed in
db.collection.insert()		->	Inserts a single doc or multiple docs into a collection

> db.dogs.insertOne({name:"Tommy",age:2,breed:"Labrador",isVaccinated:true})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("6201c30636c50eca83cf8431")
}

> show collections
dogs

> db.dogs.find()			-> Display the contents of dogs collection
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "Labrador", "isVaccinated" : true }

"_id" is primary key automatically created by Mongo. It needs to be unique for every single element in this collection

NOTE: We dont have to enforce any sort of consistent structure into a collection. We dont have to follow any format. We dont have any constraints set up.

> db.dogs.insert([{name:"Jimmy",age:1,breed:"Dalmatian",isVaccinated:false},{name:"Amy",age:3,breed:"Golden Retriever",isVaccinated:true}])
BulkWriteResult({
        "writeErrors" : [ ],
        "writeConcernErrors" : [ ],
        "nInserted" : 2,
        "nUpserted" : 0,
        "nMatched" : 0,
        "nModified" : 0,
        "nRemoved" : 0,
        "upserted" : [ ]

> db.dogs.find()
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "Labrador", "isVaccinated" : true }
{ "_id" : ObjectId("6201cb3736c50eca83cf8432"), "name" : "Jimmy", "age" : 1, "breed" : "Dalmatian", "isVaccinated" : false }
{ "_id" : ObjectId("6201cb5436c50eca83cf8434"), "name" : "Amy", "age" : 3, "breed" : "Golden Retriever", "isVaccinated" : true }

MONGO FIND
---
db.collection.find() IS SAME AS db.collection.find({})

db.collection.find(query, projection)	->	Selects document in a collection or view and returns a cursor to the selected documents
CURSOR - Pointer or reference to the results

CASE SENSITIVE
> db.dogs.find({breed:'Dalmatian'})
{ "_id" : ObjectId("6201cb3736c50eca83cf8432"), "name" : "Jimmy", "age" : 1, "breed" : "Dalmatian", "isVaccinated" : false }

FIND vs FINDONE
	FINDONE returns actual document whereas FIND returns a cursor

> db.dogs.findOne({breed:'Dalmatian'})
{
        "_id" : ObjectId("6201cb3736c50eca83cf8432"),
        "name" : "Jimmy",
        "age" : 1,
        "breed" : "Dalmatian",
        "isVaccinated" : false
}

> db.dogs.find({breed:'Dalmatian',isVaccinated:false})
{ "_id" : ObjectId("6201cb3736c50eca83cf8432"), "name" : "Jimmy", "age" : 1, "breed" : "Dalmatian", "isVaccinated" : false }

MONGO UPDATE
---
db.collection.updateOne(<filter>,<update>,<options>)	-> Updates only the first thing that matches
db.collection.updateMany(<filter>,<update>,<options>)	->	Updates all
db.collection.replaceOne(<filter>,<update>,<options>)	-> Replaces the first matching document(completely) in the collection that matches the filter,
															using the replacement document

The $set operator replaces the value of a field with the specified value. If the set field doesn't exist, it will be newly created
The $set operator expression has the following form:
	{	$set: {<field1>:<value1>, ...}	}
To specify a <field> in an embedded document or in an array, use dot notation

> db.dogs.updateOne({name:'Tommy'},{$set:{age:2,breed:'alsatian'}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

>  db.dogs.updateMany({isVaccinated: true},{$set:{isSafeToTakeOut: true}})
{ "acknowledged" : true, "matchedCount" : 2, "modifiedCount" : 2 }
> db.dogs.find()
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "alsatian", "isVaccinated" : true, "isSafeToTakeOut" : true }
{ "_id" : ObjectId("6201cb5436c50eca83cf8433"), "name" : "Jimmy", "age" : 1, "breed" : "Dalmatian", "isVaccinated" : false }
{ "_id" : ObjectId("6201cb5436c50eca83cf8434"), "name" : "Amy", "age" : 3, "breed" : "Golden Retriever", "isVaccinated" : true, "isSafeToTakeOut" : true }

NOTE: To add current timestamp to a particular field 'myDate'
> db.dogs.updateMany({},{$set:{country:'India'}, $currentDate:{myDate:true}})
{ "acknowledged" : true, "matchedCount" : 4, "modifiedCount" : 4 }
> db.dogs.find()
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "alsatian", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z") }
{ "_id" : ObjectId("6201cb5436c50eca83cf8433"), "name" : "Jimmy", "age" : 1, "breed" : "Dalmatian", "isVaccinated" : false, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z") }
{ "_id" : ObjectId("6201cb5436c50eca83cf8434"), "name" : "Amy", "age" : 3, "breed" : "Golden Retriever", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z") }

db.collection.replaceOne{
	<filter>,
	<replacement>,
	{
		upsert:	<boolean>,
		writeConcern: <document>,
		collation: <document>,
		hint: <document|string>
	}
}

MONGO DELETE
---
db.collection.deleteMany()
db.collection.deleteOne()

Delete all documents from a collection	->	Pass an empty filter document
	db.collection.deleteMany({})
Delete multiple documents based on condition -> You can specify	criteria or filters hat identify the documents to delete.
	The filters use the same stntax as read operations	i.e { <field1>:<value1>,...	}

db.dogs.deleteOne({breed:'Dalmatian',isVaccinated:false})

db.dogs.deleteMany({isVaccinated:false})

ADDITIONAL MONGO OPERATORS
---
QUERYING NESTED COLLECTIONS
> db.dogs.find()
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "alsatian", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z"), "address" : { "city" : "chennai", "country" : "india" } }

> db.dogs.find({'address.city':'chennai'})
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "alsatian", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z"), "address" : { "city" : "chennai", "country" : "india" } }

QUERY AND PROJECTION OPERATORS
COMPARISION
	$eq, $gt, $gte, $in(matches any value in specified array), $lt, $lte, $ne, $nen(matches none of the values specified in an array)

LOGICAL
	$and, $not, $nor, $or
ELEMENT
	$exists	-> Matches documents that has specified field
	$type
EVALUATION
	$expr, $jsonschema, $mod, $regex, $text, $where
GEOSPATIAL
ARRAY
BITWISE

GTE
> db.dogs.find({age:{$gte:2}})
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "alsatian", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z") }
{ "_id" : ObjectId("6201cb5436c50eca83cf8434"), "name" : "Amy", "age" : 3, "breed" : "Golden Retriever", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z") }

IN
> db.dogs.find({'breed': { $in:['Dalmatian','alsatian']} })
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "alsatian", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z"), "address" : { "city" : "chennai", "country" : "india" } }
{ "_id" : ObjectId("6201cb3736c50eca83cf8432"), "name" : "Jimmy", "age" : 1, "breed" : "Dalmatian", "isVaccinated" : false, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z") }

OR
> db.dogs.find({$or: [{age:{$gt:1}},{isVaccinated:true}]})
{ "_id" : ObjectId("6201c30636c50eca83cf8431"), "name" : "Tommy", "age" : 2, "breed" : "alsatian", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z"), "address" : { "city" : "chennai", "country" : "india" } }
{ "_id" : ObjectId("6201cb5436c50eca83cf8434"), "name" : "Amy", "age" : 3, "breed" : "Golden Retriever", "isVaccinated" : true, "isSafeToTakeOut" : true, "country" : "India", "myDate" : ISODate("2022-02-08T04:58:02.896Z"), "address" : { "city" : "chennai", "country" : "india" } }

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CONNECTING TO MONGO WITH MONGOOSE
+++++++++++++++++++++++
The role of ORM/ODMs
Connecting Mongoose to Mongo
Defining a model
Mongoose CRUD
Schema Constraints
Model Instance and Static methods
Mongoose Middleware
Mongoose Virtuals

WHAT IS MONGOOSE
---
mongoosejs.com
ODM - Object Data Mapper / Object Document Mapper
ODMs like Mongoose maps documents coming from a database into usable Javascript objects

Mongoose provides ways for us to model out our application data and define a schema.
It offers easy ways to validate data and build complex queries from the comfort of JS

	const mongoose = require('mongoose');
	mongoose.connect('mongodb://localhost:27017/test');
	const Cat = mongoose.model('Cat', { name: String });
	const kitty = new Cat({ name: 'Zildjian' });
	kitty.save().then(() => console.log('meow'));

++++++++++

	const mongoose = require('mongoose');
	mongoose.connect('mongodb://localhost:27017/animalShelter')
		.then(() => { console.log('CONNECTED!') })
		.catch(() => { console.log('OOPS..ERROR!') });

MONGOOSE MODEL
---
MODELS are javascript classes that we make with the assistance of Mongoose that represents information in a mongo database
Helps us interact with database for CRUD operations
In order to make a MODEL, we need to define a SCHEMA
Schema is a mapping of different collection keys from mongo to different types in javascript

  import mongoose from 'mongoose';
  const { Schema } = mongoose;

  const blogSchema = new Schema({
    title:  String, // String is shorthand for {type: String}
    author: String,
    body:   String,
    comments: [{ body: String, date: Date }],
    date: { type: Date, default: Date.now },
    hidden: Boolean,
    meta: {
      votes: Number,
      favs:  Number
    }
  });

  const Blog = mongoose.model('Blog', blogSchema);
  const techBlog = new Blog({ title:'machine learning', author:'vijay', body:'ML is the future', })

The permitted SchemaTypes are:

	String
	Number
	Date
	Buffer
	Boolean
	Mixed
	ObjectId
	Array
	Decimal128
	Map

INDEX.JS
	const mongoose = require('mongoose');
	mongoose.connect('mongodb://localhost:27017/movies');

	//Concept on javascript side of the equation
	const movieSchema = new mongoose.Schema({
		title: String,
		year: Number,
		score: Number,
		rating: String
	});

	//Name of the Model(singular, Capitalized) and Schema are passed as arguments
	//Save the results to a class(capitalized)
	//Mongoose will make a collection with lowercase and pluralize the model name i.e. movies
	const Movie = mongoose.model('Movie', movieSchema);

	//Now we can make new instances of movie class and save them to mongo database
	const dangal = new Movie({ title: 'Dangal', year: 2017, score: 9.3, rating: 'U' });
	dangal.save().then(() => console.log('SAVED!')).catch(() => { console.log('ERROR!') });;

> db.movies.find()
{ "_id" : ObjectId("62046ef50b41118c5c0d8c08"), "title" : "Dangal", "year" : 2017, "score" : 9.3, "rating" : "U", "__v" : 0 }


INSERTMANY
---
INDEX.JS
	//Now we can make new instances of movie class and save them to mongo database
	//Once it is saved, the promise is resolved.
	//Then callback ran and mongoose passed data into this callback
	Movie.insertMany([{ title: '3 Idiots', year: 2012, score: 9.1, rating: 'U' },
	{ title: 'Doctor', year: 2021, score: 8.7, rating: 'U' },
	{ title: 'War', year: 2018, score: 8, rating: 'U' },
	{ title: 'Cast Away', year: 1994, score: 9.7, rating: 'U' }])
		.then(() => {
			console.log('SAVED!');
			console.log(data);
		})
		.catch(() => {
			console.log('ERROR!')
		});


> db.movies.find()
{ "_id" : ObjectId("62046ef50b41118c5c0d8c08"), "title" : "Dangal", "year" : 2017, "score" : 9.3, "rating" : "U", "__v" : 0 }
{ "_id" : ObjectId("6205de6350fbd339b92746e4"), "title" : "3 Idiots", "year" : 2012, "score" : 9.1, "rating" : "U", "__v" : 0 }
{ "_id" : ObjectId("6205de6350fbd339b92746e5"), "title" : "Doctor", "year" : 2021, "score" : 8.7, "rating" : "U", "__v" : 0 }
{ "_id" : ObjectId("6205de6350fbd339b92746e6"), "title" : "War", "year" : 2018, "score" : 8, "rating" : "U", "__v" : 0 }
{ "_id" : ObjectId("6205de6350fbd339b92746e7"), "title" : "Cast Away", "year" : 1994, "score" : 9.7, "rating" : "U", "__v" : 0 }

FINDING DOCUMENTS
---
Model.find(filter[,projection][,options][,callback])
	Mongoose casts the filter to match the model's schema before the command is sent

Examples,
   await MyModel.find({});
	Movie.find({}).then((data) => console.log(data)).catch((error) => console.log(error));
	Movie.find({ score: { $gt: 9 } }).then((data) => console.log(data)).catch((error) => console.log(error));
WITH EXEC, IT GIVES BETTER STACK TRACES. IT INCLUDES THE CALLING CODE
	Movie.find({ score: { $gt: 9 } }).exec().then((data) => console.log(data)).catch((error) => console.log(error));
FINDS THE FIRST MATCH
	Movie.findOne({ score: { $gt: 9 } }).then((data) => console.log(data)).catch((error) => console.log(error));
FINDING BY ID
	Movie.find({ _id: '62046ef50b41118c5c0d8c08' }).then((data) => console.log(data)).catch((error) => console.log(error));
	Movie.findById('62046ef50b41118c5c0d8c08').then((data) => console.log(data)).catch((error) => console.log(error));


UPDATING DOCUMENTS
---
Model.updateMany(filter[,doc][,options][,callback])
Updates only the first document that matches the filter
Model.updateOne(filter[,doc][,options][,callback])

	Movie.updateOne({ title: 'Dangal' }, { $set: { score: 9.5 } }).then((data) => console.log(data)).catch((error) => console.log(error));
	Movie.updateMany({ title: { $in: ['3 Idiots', 'War'] } }, { $set: { score: 10 } }).then((data) => console.log(data)).catch((error) => console.log(error));


Finds one, updates and gives us the object after the update was applied
We get back the object(default is old) with the new information
{new:true} -> returns the modified document rather than the original document
A.findOneAndUpdate(conditions, update, options, callback);  -> executes
A.findOneAndUpdate(conditions, update, options);  -> returns query
A.findOneAndUpdate(conditions, update, callback);  -> executes
A.findOneAndUpdate(conditions, update);  -> returns query
A.findOneAndUpdate();  -> returns query

Model.updateMany(filter[,doc][,options][,callback])
Updates only the first document that matches the filter
Model.updateOne(filter[,doc][,options][,callback])

	Movie.findOneAndUpdate({ title: 'Dangal' }, { $set: { score: 9.9 } }).then((data) => console.log(data)).catch((error) => console.log(error));
	Movie.findOneAndUpdate({ title: 'Dangal' }, { $set: { score: 9.8 } }, { new: true }).then((data) => console.log(data)).catch((error) => console.log(error));

DELETING DOCUMENTS
---
This method sends a remove command directly to mongodb. No documents are involved
Removes all documents that matches condition from the collection
To remove just the first document that matches conditions, set the single option to true
Model.deleteOne(conditions[, options])
Model.findOneAndDelete -> To return back the deleted item

	Movie.deleteOne({ title: 'Dangal' }).then((data) => console.log(data)).catch((error) => console.log(error));
	Movie.deleteMany({}).then((data) => console.log(data)).catch((error) => console.log(error));
	Movie.deleteMany({ score: { $gt: 9 } }).then((data) => console.log(data)).catch((error) => console.log(error));
	Movie.findOneAndDelete({ title: 'Doctor' }).then((data) => console.log(data)).catch((error) => console.log(error));

MONGOOSE SCHEMA VALIDATIONS
---
OPERATION BUFFERING - Mongoose lets you start using your models immediately, without waiting for mongoose to eastablish a connection with mongoDB

//This structure helps us to add built-in validations
const productSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    price: {
        type: Number
    }
});

const Product = mongoose.model('Product', productSchema);

const cornFlakes = new Product({ name: 'Kellogs', price: 285 });
cornFlakes.save().then(() => console.log('SAVED!')).catch(() => { console.log('ERROR!') });
//Below will throw validation error
//Error: Product validation failed: name: Path `name` is required.
const unnamed = new Product({ price: 10 });
unnamed.save().then(() => console.log('SAVED!')).catch((err) => { console.log('ERROR!'); console.log(err) });
//Below will throw validation error
//Error: Product validation failed: price: Cast to Number failed for value "twenty" (type string) at path "price"
const noodles = new Product({ name: 'Maggi', price: 'twenty' });
noodles.save().then(() => console.log('SAVED!')).catch((err) => { console.log('ERROR!'); console.log(err) });
//color: 'green' will not be saved since it was not part of the schema.
//price: '140' will be saved, since the value is still a number
const shampoo = new Product({ name: 'Patanjali', price: '140', color: 'green' });
shampoo.save().then(() => console.log('SAVED!')).catch((err) => { console.log('ERROR!'); console.log(err) });

Error is as follows:
Error: Product validation failed: name: Path `name` is required.
 errors: {
    name: ValidatorError: Path `name` is required.
      properties: [Object],
      kind: 'required',
      path: 'name',
      value: undefined,
      reason: undefined,
      [Symbol(mongoose:validatorError)]: true
    }
  },
  _message: 'Product validation failed'
}

ADDITIONAL SCHEMA CONSTRAINTS
---
SchemaTypes options:
	required
	default
	select
	validate
	get
	set
	alias
	immutable
	transform

String:
	lowercase
	uppercase
	trim
	match	-> RegExp, creates a validator that checks if the value matches the given regular expression
	enum	-> Allows us to provide an array of potential string values and it's a validation to make sure that the value is in that array
	minlength
	maxlength

Number:
	min
	max
	enum

VALIDATING MONGOOSE UPDATES
---

NOTE:In case of create, validations are automatically applied. Whereas in case of update, it needs to be mentioned explicitly
UNDER options -> runValidators:true

//Example of UPSERT where validation errors are ignored by default
const cycle1 = new Product({ name: 'BTWIN', price: 12500, competitors: ['Hercules', 'Atlas'] });
cycle1.save()
    .then((data) => {
        console.log('SAVED!');
        console.log(data);
        //Bu default, only create will handle validation errors and NOT update.
        //In below example, negative price validation will be ignored
        Product.findOneAndUpdate({ name: 'BTWIN' }, { $set: { price: -90 } }, { new: true })
            .then((data) => {
                console.log('SAVED!');
                console.log(data);
            })
            .catch((err) => {
                console.log('ERROR!');
                console.log(err)
            });
    })
    .catch((err) => {
        console.log('ERROR!');
        console.log(err)
    });

//Example of UPSERT where validation errors are handled using runValidators:true
const cycle2 = new Product({ name: 'Hero', price: 3500, competitors: ['Hercules', 'Atlas'] });
cycle2.save()
    .then((data) => {
        console.log('SAVED!');
        console.log(data);
        //Bu default, only create will handle validation errors and NOT update.
        //In below example, negative price validation will be considered using runValidators:true
        //Error: Validation failed: price: Path `price` (-100) is less than minimum allowed value (0).
        Product.findOneAndUpdate({ name: 'Hero' }, { $set: { price: -100 } }, { new: true, runValidators: true })
            .then((data) => {
                console.log('SAVED!');
                console.log(data);
            })
            .catch((err) => {
                console.log('ERROR!');
                console.log(err)
            });
    })
    .catch((err) => {
        console.log('ERROR!');
        console.log(err)
    });

MONGOOSE VALIDATION ERRORS
---
Custom validation Error Messages. For example,
	min: [0, 'Price must be positive.My Custom Message!']

MODEL INSTANCE METHODS VS STATICS
---
INSTANCE METHODS
Adding custom functionality to the model in addition to whatever mongoose already provides
Instance method is available on every single instance. Instances of Models are documents.
Documents have many of their own built-in instance methods.We may also define our own custom document instance methods

//define a schema
var animalSchema = new Schema({name:String, type:String});

//assign a function i.e.findSimilarTypes to the 'methods' object of our animalSchema
animalSchema.methods.findSimilarTypes = function(cb){
	return mongoose.model('Animal'.find({type:this.type},cb);
}

//now all of our animal instances have a findSimilarTypes method available to them
var Animal = mongoose.model('Animal',animalSchema);
var dog = new Animal({name:'Tommy', type:'Dog'});

dog.findSimilarTypes(function(err,dogs){
	console.log(dogs);
});

STATICS
There are 2 equivalent ways to add a Static
	1)Add a function property to schema.statics
	2)Call the Schema#static() function

	//assign a function to the "statics" object of our animal schema
	animalSchema.statics.findByName = function(name){
		return this.find({ name: new RegExp(name, 'i')});
	}

	//or equivalently, you can call animalSchema.static
	animalSchema.static('findByBreed',function(breed){
		return this.find({ breed });
	}

	const Animal = mongoose.model('Animal',animalSchema);
	let animals = await Animal.findByName('fido');
	animals = animals.concat(await Animal.findByBreed('poodle'));

NOTE: Do not declare statics using ES6 arrow functions(=>), as Arrow functions explicitly prevents binding this
Static methods on the model often have usecases such as CRUDing things. They are usually built on top of existing model
methods like findProducts, updateProducts
Instance methods operate on individual instances of the model i.e toggleOnSale on an (THIS)individual instance of product
Static methods - THIS refers to the entire MODEL

MONGOOSE VIRUTALS
---
Virtuals are document properties that you can get and set, but that do not get persisted to MongoDB.
The getters are useful for formatting or combining fields, while setters are useful for decomposing
a single value into multiple values for storage.

In Mongoose, a virtual is a property that is not stored in MongoDB. Virtuals are typically used for computed properties on documents.
They give us the ability to add property to schema that doesnt exist in the database itself

const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/personsApp');
//define a schema
var personSchema = new mongoose.Schema({
    name: {
        first: String,
        last: String
    }
});

personSchema.virtual('fullName').get(function () {
    return `${this.name.first} ${this.name.last}`;
}).set(function (value) {
    this.name.first = value.substr(0, value.indexOf(' '));
    this.name.last = value.substr(value.indexOf(' ') + 1, value.length);
});

//compile our model
const Person = mongoose.model('Person', personSchema);

//create a document
const person1 = new Person({
    name: {
        first: "Vijay",
        last: "Anand"
    }
});

console.log(person1.name.first + " " + person1.name.last);
console.log('+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');
//Alternatively a virtual property getter lets you define a fullname property
//that won't persisted to MongoDB
console.log(person1.fullName);
//Saving into Mongo
person1.save();

const person2 = new Person({
    name: {
        first: 'Priyanka',
        last: 'KV'
    }
});
console.log(person2.fullName);
person2.fullName = 'Priyanka Vijay'
person2.save();


//If you use JSON.stringify i.e toJSON(), mongoose wil not include virtuals by default
	console.log(JSON.stringify(person2));
THIS WILL PRINT
	{"name":{"first":"Priyanka","last":"Vijay"},"_id":"6210e46f3fc3e5dbb57e79eb"}

//Pass {virtuals:true} to include virtuals
	console.log(person2.toJSON({ virtuals: true }));
THIS WILL PRINT
	{
	  name: { first: 'Priyanka', last: 'Vijay' },
	  _id: new ObjectId("6210e46f3fc3e5dbb57e79eb"),
	  fullName: 'Priyanka Vijay',
	  id: '6210e46f3fc3e5dbb57e79eb'
	}

DEFINING MONGOOSE MIDDLEWARE
---
Mongoose gives us the ability to run code before and after certain things are executed

Middleware(also called pre and post hooks) are functions which are passed control during execution of asynchronous functions
Middleware is specified on the schema level and is useful for writing plugins

personSchema.pre('save', function () {
    this.fullName = 'Jim Carrey'
    console.log('BEFORE SAVE!')
});
personSchema.post('save', function () {
    console.log('AFTER SAVE!')
});

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MONGOOSE WITH EXPRESS
++++++++
INTEGRATING MONGOOSE WITH EXPRESS
DEFINING OUR MODEL
PRODUCTS INDEX
PRODUCT DETAILS
CREATING PRODUCTS
UPDATING PRODUCTS
DELETING PRODUCTS
FILTERING BY CATEGORY

EXPRESS + MONGOOSE
---
EXAMPLE : USING PRODUCTS AS RESOURCE
Index - GET /products - List all products
New - GET /products/new - FORM to create a new product
Create - POST /products - Create a new product
Show - GET /products/:id - Get one product(using id)
Edit - GET /products/:id/edit - FORM to edit specific product(using id)
Update - PATCH /products/:id - Update one product(using id)
Destroy - DELETE /products/:id - Delete one product(using id)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
EXPRESS MIDDLEWARE
++++++++++++++++++
MIDDLEWARE CONCEPTS
MORGAN LOGGING MIDDLEWARE
WRITING CUSTOM MIDDLEWARE

INTRO TO EXPRESS MIDDLEWARE
---
Express Middelware are functions that run during the request/response lifecycle.

Middleware are just FUNCTIONS which can execute any code
Each Middleware has access to the Request and Response objects
Middleware can end a HTTP Request by sending back a response with methods like res.send()
OR Middleware can be chained together, one after another by calling next()

MORGAN LOGGING MIDDLEWARE
---
HTTP request Logger middleware for Node.js

var morgan = require('morgan')

morgan(format,options) -> Create a new morgan logger middleware function using the given format and options

morgan('tiny') - Using a predefined format string
morgan(':method :url :status :res[content-length] - :response-time ms') -> Using format string of predefined tokens

NOTE: In order to use Morgan as middleware, you need to tell your application to "USE" morgan
i.e. APP.USE is a way of just getting some code to run on every single request

app.use(morgan('tiny')); //On every single request, use morgan middleware function
	GET / 304 - - 4.321 ms
app.use(morgan('dev')); //For developer users. Colorizes response code
	GET /dogs 304 5.409 ms - -
app.use(morgan('common'))
	::1 - - [23/Jun/2022:09:26:08 +0000] "GET /dogs HTTP/1.1" 304 -

DEFINING OUR OWN MIDDLEWARE
----
The third parameter next is just a function. Just executing next is going to invoke whatever the next matching middleware or route handler is

app.use((req, res, next) => {
    console.log('THIS IS MY FIRST MIDDLEWARE!!');
    next();
    console.log('THIS IS MY FIRST MIDDLEWARE - AFTER CALLING NEXT !!');
});

app.use((req, res, next) => {
    console.log('THIS IS MY SECOND MIDDLEWARE!!');
    next();
});

App is running on localhost 3000
THIS IS MY FIRST MIDDLEWARE!!
THIS IS MY SECOND MIDDLEWARE!!
THIS IS MY FIRST MIDDLEWARE - AFTER CALLING NEXT !!
::1 - - [24/Jun/2022:08:07:05 +0000] "GET /dogs HTTP/1.1" 304 -

SETTING UP A 404 ROUTE
---
Sometimes we may want to use a middleware on a particular route

app.use('/dogs', (req, res, next) => {
    console.log('THIS IS MY DOG EXCLUSIVE MIDDLEWARE!!');
    next();
});

PASSWORD MIDDLEWARE DEMO
---
app.use((req, res, next) => {
    const { password } = req.query;
    if (password === 'secret') {
        next();
    }
    res.send('NOT AUTHENTICATED!');
});

http://localhost:3000/dogs?password=secret

PROTECTING SPECIFIC ROUTES
---
const verifyPassword = (req, res, next) => {
    const { password } = req.query;
    if (password === 'secret') {
        next();
    }
    res.send('NOT AUTHENTICATED!');
}

app.use('/secureroute', verifyPassword, (req, res, next) => {
    console.log('THIS IS MY SECURE ROUTE!!');
    res.send('SECURE PAGE');
});

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
EJS MATE
++++++++
Express 4.x layout, partial and block template function for the EJS template engine

npm install ejs-mate --save

Given a template, index.ejs:
	<% layout('boilerplate') -%>
	<h1>I am the <%= what %> template</h1>

And a layout, boilerplate.ejs:
	<!DOCTYPE html>
	<html>
	  <head>
		<title>It's <%= who %></title>
	  </head>
	  <body>
		<section>
		  <%- body -%>
		</section>
	  </body>
	</html>

When rendered by an Express 4.0 app:
	var express = require('express'),
	engine = require('ejs-mate'),
	app = express();

	// use ejs-locals for all ejs templates:
	app.engine('ejs', engine);

	app.set('views', __dirname + '/views');
	app.set('view engine', 'ejs'); // so you can render('index')

	// render 'index' into 'boilerplate':
	app.get('/',function(req,res,next){
	  res.render('index', { what: 'best', who: 'me' });
	});

	app.listen(3000);

You get the following result:
	<!DOCTYPE html>
	<html>
	  <head>
		<title>It's me</title>
	  </head>
	  <body>
		<section>
		  <h1>I am the best template</h1>
		</section>
	  </body>
	</html>

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HANDLING ERRORS IN EXPRESS APP
++++++++++++++++++++++++++++++
EXPRESS BUILT-IN ERROR HANDLER
DEFINING CUSTOM ERROR HANDLERS
HANDLING ASYNC ERRORS
WORKING WITH MONGOOSE ERRORS
DEFINING CUSTOM ERROR CLASS


EXPRESS BUILT-IN ERROR HANDLERS
---
How do we handle errors in an express application?
How express catches and processes error that occurs both synchronously and asynchronously
Express comes with a default error handler, so you don't need to write your own to get started
It responds with a default 500 status error code. It makes a little HTML page with a stack trace

app.get('/error',(req,res)=>{
	throw new Error("My Error");
})

Error: My Error
    at C:\Users\vijayanand.s\WebDevelopment\Node\morganMiddleware_21\index.js:22:11

app.get('/error2', (req, res) => {
    chicken.fly();
});
ReferenceError: chicken is not defined
    at C:\Users\vijayanand.s\WebDevelopment\Node\morganMiddleware_21\index.js:26:5


WRITING ERROR HANDLERS
---
Define error handling middleware functions in the same way as other middleware functions, except error handling
requires four arguments instead of three: (err, req, res, next)

//THIS ERROR HANDLING MIDDLEWARE WILL RUN IF ANY ERROR IS THROWN
app.use(function (err, req, res, next) {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});

When an error is written, the following information is added to the response
	-> The res.statusCode is set from err.status(or err.statusCode). If this value is outside the 4xx or 5xx range, it will be set to 500
	-> The res.statusMessage is set according to the status code
	-> The body will be the HTML of the status code message when in production environment, otherwise will be err.stack
	-> Any headers specified in an err.headers object

OUR CUSTOM ERROR CLASS
---
Generally when express throws an error, we respond with a particular status code and a message
Set up a generic custom error

class AppError extends Error {
    constructor(message, status) {
        super();
        this.message = message;
        this.status = status;
    }
}

module.exports = AppError;
---

app.get('/error2', (req, res) => {
    chicken.fly();
});

app.use(function (err, req, res, next) {
    const { status } = err;
    console.error(err.stack);
    res.status(status).send('Something broke!');
});

RangeError [ERR_HTTP_INVALID_STATUS_CODE]: Invalid status code: undefined

To avoid this error, we default the status code
app.use(function (err, req, res, next) {
    const { status = 500 } = err;
    console.error(err.stack);
    res.status(status).send('Something broke!');
});

HANDLING ASYNC ERRORS
---
Errors that occur in SYNCHRONOUS code inside route handlers and middleware require no extra work.
If synchronous code throws an error, then Express will catch and process it. For example
	app.get('/products/new', (req, res) => {
		throw new AppError('product not found', '401');
		res.render('products/new');
	});

	Returns
	product not found
	GET http://localhost:3000/products/new 401 (Unauthorized)

For errors returned from ASYNCHRONOUS functions, invoked by route handlers and middleware,
you MUST pass them to the NEXT function, where express will catch and process them

	app.get('/products/:id', async (req, res, next) => {
		const { id } = req.params;
		const product = await Product.findById(id);
		if (!product) {
			next(new AppError('product not found', '401'));
		}
		res.render(`products/show`, { product });
	});


But in the console, it returns error "Cannot read properties of null (reading 'name')"
This is because res.render is going to run anyway with null entries
Solution is to RETURN the next or use an ELSE

	app.get('/products/:id', async (req, res, next) => {
		const { id } = req.params;
		const product = await Product.findById(id);
		if (!product) {
			return next(new AppError('product not found', '401'));
		}
		res.render(`products/show`, { product });
	});

The custom error works fine when no product is found.But what about other errors
such as the one from mongoose or validation errors
i.e. ValidationError: Product validation failed: name: Path `name` is required.
Solution is to WRAP IT WITH A TRY CATCH so that it will try all of those
statements and if anything goes wrong, it will catch the error

	app.post('/products', async (req, res, next) => {
		try {
			console.log(req.body);
			const newProduct = new Product(req.body);
			await newProduct.save();
			const products = await Product.find({});
			console.log('+++++++++++++++++++++++++++++++++');
			console.log(products);
			res.render('products/index', { products });
		} catch (e) {
			next(e);
		}
	});

Then we will get the following error -> Product validation failed: name: Path `name` is required.

Rather than wrapping every async method with try/catch, we can create a reusable async utility
SOLUTION -> If an error is thrown in a function and if it's not caught, we can catch it in parent function
The Wrapping function needs to return another function(req,res,next) by chaining on a catch function and
if there is an error,pass it to the next function


	function wrapAsync(fn) {
		return function (req, res, next) {
			fn(req, res, next).catch((e) => { next(e) });
		}
	};

	app.post('/products', wrapAsync(async (req, res, next) => {
		console.log(req.body);
		const newProduct = new Product(req.body);
		await newProduct.save();
		const products = await Product.find({});
		console.log('+++++++++++++++++++++++++++++++++');
		console.log(products);
		res.render('products/index', { products });
	}));

NOTE: Express 5 will be able to handle asynchronous functions that throw errors automatically

DIFFERENTIATING MONGOOSE ERRORS
---

db.processMetrics.count({$expr:{$gt:[ { $toInt: "$pi_PercentProcessorTime" }, 70 ]},tool_name:'Monitoring',group_name:'Prod',machine_name:'W10ZDIP0010',iso_timestamp:{$gte:ISODate("2022-06-30T14:37:57Z"),$lt:ISODate("2022-06-30T14:57:57Z")}})
db.processMetrics.count({tool_name:'Monitoring',group_name:'Prod',machine_name:'200411LTP0984',iso_timestamp:{$gte:ISODate("2022-07-04T10:24:51Z"),$lt:ISODate("2022-07-04T10:44:51Z")}})

We can intercept particular error types and modify them or build new errors based upon them


app.use((err, req, res, next) => {
    console.log(err.name);
    next(err);
});

ValidationError
	Product validation failed: name: Path `name` is required.

CastError
	http://localhost:3000/products/fsdfsdjfdfsdfsjifogjiogdgsdgsdg
	Cast to ObjectId failed for value "fsdfsdjfdfsdfsjifogjiogdgsdgsdg" (type string) at path "_id" for model "Product"

const productSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'name cannot be blank']	-> WE CAN SET CUSTOM MESSAGES HERE
    },
    price: {
        type: Number,
        required: true,
        min: 0
    },
    category: {
        type: String,
        lowercase: true,
        enum: ['fruit', 'vegetable', 'dairy']
    }
});

ValidationError: Product validation failed: name: name cannot be blank	-> CUSTOM MESSAGES DISPLAYED HERE

const handleValidationError = err => {
    console.dir(err);
    return new AppError(`VALIDATION FAILED CUSTOM MESSAGE .. ${err.message}`, 400);
}

app.use((err, req, res, next) => {
    console.log(err.name);
    if (err.name === "ValidationError") {
        err = handleValidationError(err);
    }
    next(err);
});

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
YELPCAMP - ERRORS AND VALIDATING DATA
++++++++++++++++++++++++++++++
CLIENT-SIDE VALIDATION
SERVER-SIDE VALIDATION
ERROR HANDLING
ERROR TEMPLATE
JOI

CLIENT SIDE FORM VALIDATIONS
----
Native HTML5 "REQUIRED" Attribute. Downside is that the implementation is not standardized across all browsers
SOLUTION:
	Bootstrap comes with its own validation helpers
	HTML Form validation is applied via CSS's two pseudo classes, :invalid and :valid
	It applies to <input>, <select> and <textarea> elements
HOW IT WORKS:
	Use Native HTML5 "required" Attribute on the form elements i.e. <input>, <select> and <textarea>
	Then tell browser, not to validate the form using "novalidate" -> Bootstrap will take over instead of native browser validation
	"novalidate" will prevent all "required" stuff from actually requiring anything

	JAVASCRIPT
		We also need to add some javascript -> This will prevent us from submitting the form when things are invalid
    <script>
        // Example starter JavaScript for disabling form submissions if there are invalid fields
        (function () {
            'use strict'

            // Fetch all the forms we want to apply custom Bootstrap validation styles to
            var forms = document.querySelectorAll('.needs-validation')

            // Loop over them and prevent submission
            Array.prototype.slice.call(forms)
                .forEach(function (form) {
                    form.addEventListener('submit', function (event) {
                        if (!form.checkValidity()) {
                            event.preventDefault()
                            event.stopPropagation()
                        }

                        form.classList.add('was-validated')
                    }, false)
                })
        })()
    </script>

	FEEDBACK
		<div class="valid-feedback">Looks good!</div> -> Add at the bottom of every form element

BASIC ERROR HANDLER
---
CastError: Cast to Number failed for value "qweq" (type string) at path "price"

SOLUTION -> Try/Catch or wrap the Async function with error handler

	utils/ExpressError.js
	---
	class ExpressError extends Error {
		constructor(message, status) {
			super();
			this.message = message;
			this.status = status;
		}
	}

	module.exports = ExpressError;

	utils/CatchAsync.js
	---
	module.exports = func => {
		return (req, res, next) => {
			func(req, res, next).catch(next);
		}
	};

	app.js
	---
	const ExpressError = require('./utils/ExpressError');
	const catchAsync = require('./utils/CatchAsync');

	app.all('*', (req, res, next) => {
		next(new ExpressError('Page Not Found', 404));
	})

	const handleError = err => {
		console.dir(err);
		return new ExpressError(`FAILED CUSTOM MESSAGE .. ${err.message}`, 400);
	}

	const handleValidationError = err => {
		console.dir(err);
		return new ExpressError(`VALIDATION FAILED CUSTOM MESSAGE .. ${err.message}`, 400);
	}

	const handleCastError = err => {
		console.dir(err);
		return new ExpressError(`CAST FAILED CUSTOM MESSAGE .. ${err.message}`, 400);
	}

	app.use((err, req, res, next) => {
		console.log(err.name);
		if (err.name === "Error") {
			err = handleError(err);
		} else if (err.name === "ValidationError") {
			err = handleValidationError(err);
		} else if (err.name === "CastError") {
			err = handleCastError(err);
		}
		next(err);
	});

	app.use((err, req, res, next) => {
		const { status = '500', message = 'Something went wrong!' } = err;
		res.status(status).send(message);
	});

BACKEND VALIDATION USING POSTMAN
---
app.post('/campgrounds', catchAsync(async (req, res) => {
    if (!req.body.campground) {
        throw new ExpressError("Campground Body Is Empty", 400);
    }
    const campground = new Campground(req.body.campground);
    await campground.save();
    //res.redirect(`campgrounds/` + campground._id);
    res.redirect(`campgrounds/${campground._id}`);
}));

Then if we pass
	curl --location --request POST 'http://localhost:3000/campgrounds' \
	--header 'Content-Type: application/x-www-form-urlencoded' \
	--data-urlencode 'campground=hello'
We get an error
	Parameter "obj" to Document() must be an object, got hello

ERROR TEMPLATE - error.ejs
	<% layout('layouts/boilerplate') %>
    <div class="row">
        <div class="col-6 offset-3">
            <div class="alert alert-danger" role="alert">
                <h4 class="alert-heading">Error!</h4>
                <p>
                    <%= err.message%>
                </p>
                <hr>
                <p class="mb-0">
                    <%= err.stack%>
                </p>
            </div>
        </div>
    </div>

INVOKING FROM app.js
	app.use((err, req, res, next) => {
		const { status = '500', message = 'Something went wrong!' } = err;
		//res.status(status).send(message);
		res.status(status).render('error', { err });
	});

JOI SCHEMA VALIDATIONS
---
JOI - Javascript Validator Tool
joi lets you describe your data using a simple, intuitive, and readable language.
Basically we define a schema for some data in javascript

const Joi = require('joi');

const schema = Joi.object({
    username: Joi.string()
        .alphanum()
        .min(3)
        .max(30)
        .required(),

    password: Joi.string()
        .pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')),

    repeat_password: Joi.ref('password'),

    access_token: [
        Joi.string(),
        Joi.number()
    ],

    birth_year: Joi.number()
        .integer()
        .min(1900)
        .max(2013),

    email: Joi.string()
        .email({ minDomainSegments: 2, tlds: { allow: ['com', 'net'] } })
})
    .with('username', 'birth_year')
    .xor('password', 'access_token')
    .with('password', 'repeat_password');


schema.validate({ username: 'abc', birth_year: 1994 });
// -> { value: { username: 'abc', birth_year: 1994 } }

schema.validate({});
// -> { value: {}, error: '"username" is required' }

// Also -

try {
    const value = await schema.validateAsync({ username: 'abc', birth_year: 1994 });
}
catch (err) { }

------------------------------

app.post('/campgrounds', catchAsync(async (req, res) => {
    /*
    if (!req.body.campground) {
        throw new ExpressError("Campground Body Is Empty", 400);
    }
    */
    const campgroundSchema = Joi.object({
        campground: Joi.object({
            title: Joi.string().required(),
            price: Joi.number().required().min(0),
            image: Joi.string().required(),
            location: Joi.string().required(),
            description: Joi.string().required()
        })
    }).required();
    const { error } = campgroundSchema.validate(req.body);
    if (error) {
        const msg = error.details.map(el => el.message).join(',');
        throw new ExpressError(msg, 400);
    }
    console.log(result);

    const campground = new Campground(req.body.campground);
    await campground.save();
    //res.redirect(`campgrounds/` + campground._id);
    res.redirect(`campgrounds/${campground._id}`);
}));

curl --location --request POST 'http://localhost:3000/campgrounds' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'campground[title]=hello' \
--data-urlencode 'campground[price]=-5' \
--data-urlencode 'campground[image]=fsfssf' \
--data-urlencode 'campground[location]=sffs' \
--data-urlencode 'campground[description]=sddsdff'

Error
ExpressError: "campground.price" must be greater than or equal to 0

JOI VALIDATION MIDDLEWARE
----
We will build a reusable middleware by name validateCampground and we will use it anywhere we would need to validate req.body.campground

schemas.js

	const Joi = require('joi');

	module.exports.campgroundSchema = Joi.object({
		campground: Joi.object({
			title: Joi.string().required(),
			price: Joi.number().required().min(0),
			image: Joi.string().required(),
			location: Joi.string().required(),
			description: Joi.string().required()
		}).required()
	});

app.js

	const validateCampground = (req, res, next) => {
		const { error } = campgroundSchema.validate(req.body);
		if (error) {
			const msg = error.details.map(el => el.message).join(',');
			throw new ExpressError(msg, 400);
		} else {
			next();
		}
	}

	app.put('/campgrounds/:id', validateCampground, catchAsync(async (req, res) => {
		const campground = await Campground.findByIdAndUpdate(req.params.id, req.body.campground, { new: true });
		res.render('campgrounds/show', { campground });
	}));


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DATA RELATIONSHIPS WITH MONGO
++++++++++++++++++++++++++++++
SQL RELATIONSHIPS OVERVIEW
ONE TO FEW
ONE TO MANY
ONE TO BAJILLIONS
POPULATE
MONGO SCHEMA DESIGN

ONE TO FEW
---
EMBED THE DATA DIRECTLY IN THE DOCUMENT

Example -> User with one or more addresses

user.js

		const mongoose = require('mongoose');
		mongoose.connect('mongodb://localhost:27017/relationshipDemo', { useNewUrlParser: true })
			.then(() => {
				console.log('MONGO CONNECTION OPEN!');
			})
			.catch(() => {
				console.log('OOPS..MONGO CONNECTION ERROR!');
				console.log(err);
			});
		const userSchema = new mongoose.Schema({
			first: {
				type: String,
				required: true
			},
			last: {
				type: String,
				required: true
			},
			addresses: [
				{
					street: String,
					area: String,
					city: String,
					country: String
				}
			]
		});
		const User = mongoose.model('User', userSchema);
		const makeUser = async () => {
			const newUser = new User({
				first: 'vijay',
				last: 'anand'
			});
			newUser.addresses.push({
				street: 'Nookampalayam Main Road',
				area: 'Perumbakkam',
				city: 'Chennai',
				country: 'India'
			})
			const result = await newUser.save();
			console.log(result);
		}

		makeUser();

RESULT
		{
		  first: 'vijay',
		  last: 'anand',
		  _id: new ObjectId("62ce2fdf9207d1ddc78f1382"),
		  addresses: [
			{
			  street: 'Nookampalayam Main Road',
			  area: 'Perumbakkam',
			  city: 'Chennai',
			  country: 'India',
			  _id: new ObjectId("62ce2fdf9207d1ddc78f1383")
			}
		  ],
		  __v: 0
		}

NOTE: The address also have an _id. Mongo generally adds an _id for each document. Mongo is going to treat behind the scenes
as its own embedded schema. It is a way of reusing i.e breaking up document schemas into smaller pieces
You can turn off the  embedded id using

	_id: { id: false }

Then the result becomes

	{
	  first: 'vijay',
	  last: 'anand',
	  _id: new ObjectId("62ce326c403d3f9a0fe24930"),
	  addresses: [
		{
		  street: 'Nookampalayam Main Road',
		  area: 'Perumbakkam',
		  city: 'Chennai',
		  country: 'India'
		}
	  ],
	  __v: 0
	}

Adding address to an existing user

	const addAddress = async () => {
		const existingUser = await User.findById('62ce2fdf9207d1ddc78f1382');
		existingUser.addresses.push({
			street: 'Mambakkam Main Road',
			area: 'Medavakkam',
			city: 'Chennai',
			country: 'India'
		})
		const result = await existingUser.save();
		console.log(result);
	}

	//makeUser();
	addAddress();


Result becomes
	{
	  _id: new ObjectId("62ce2fdf9207d1ddc78f1382"),
	  first: 'vijay',
	  last: 'anand',
	  addresses: [
		{
		  _id: new ObjectId("62ce2fdf9207d1ddc78f1383"),
		  street: 'Nookampalayam Main Road',
		  area: 'Perumbakkam',
		  city: 'Chennai',
		  country: 'India'
		},
		{
		  street: 'Mambakkam Main Road',
		  area: 'Medavakkam',
		  city: 'Chennai',
		  country: 'India'
		}
	  ],
	  __v: 1
	}

ONE TO MANY
---
STORE YOUR DATA SEPERATELY, BUT THEN STORE REFERENCES TO DOCUMENT IDS SOMEWHERE INSIDE THE PARENT

Usually we do this using object id, and we can store an array of ids
https://www.geeksforgeeks.org/mongoose-populate-method/
https://mongoosejs.com/docs/populate.html

MongoDB has the join-like $lookup aggregation operator in versions >= 3.2.
Mongoose has a more powerful alternative called populate(), which lets you reference documents in other collections.

Population is the process of automatically replacing the specified paths in the document with document(s) from other collection(s).
We may populate a single document, multiple documents, a plain object, multiple plain objects, or all objects returned from a query.

The "ref" option is what tells mongoose, which "model" to use during population

	const mongoose = require('mongoose');
	const { Schema } = mongoose;

	const personSchema = Schema({
	  _id: Schema.Types.ObjectId,
	  name: String,
	  age: Number,
	  stories: [{ type: Schema.Types.ObjectId, ref: 'Story' }]
	});

	const storySchema = Schema({
	  author: { type: Schema.Types.ObjectId, ref: 'Person' },
	  title: String,
	  fans: [{ type: Schema.Types.ObjectId, ref: 'Person' }]
	});

	const Story = mongoose.model('Story', storySchema);
	const Person = mongoose.model('Person', personSchema);

ANOTHER EXAMPLE
	const mongoose = require('mongoose');

	mongoose.connect('mongodb://localhost:27017/relationshipDemo', { useNewUrlParser: true })
		.then(() => {
			console.log('MONGO CONNECTION OPEN!');
		})
		.catch(() => {
			console.log('OOPS..MONGO CONNECTION ERROR!');
			console.log(err);
		});

	const productSchema = new mongoose.Schema({
		name: {
			type: String,
			required: true
		},
		price: {
			type: Number,
			required: true
		},
		season: {
			type: String,
			enum: ['Spring', 'Summer', 'Fall', 'Winter'],
			required: true
		}
	});

	const Product = mongoose.model('Product', productSchema);

	const farmSchema = new mongoose.Schema({
		name: String,
		city: String,
		products: [
			{ type: mongoose.Schema.Types.ObjectId, ref: 'Product' }
		]
	});

	const Farm = mongoose.model('Farm', farmSchema);

	/*
	Product.insertMany(
		[
			{ name: 'Goddess Melon', price: 3.5, season: 'Summer' },
			{ name: 'Sugar baby watermelon', price: 4, season: 'Fall' },
			{ name: 'Asparagus', price: 9.25, season: 'Spring' }
		]
	);
	*/

	const addProduct = async (farm, productName) => {
		const product = await Product.findOne({ name: `${productName}` });
		farm.products.push(product);
	};

	const makeFarm = async () => {
		const farm = new Farm({
			name: 'Full Belly Farm',
			city: 'Guinda, CA'
		});
		/*
		const melon = await Product.findOne({ name: 'Goddess Melon' });
		console.log('MELON\n' + melon);
		farm.products.push(melon);
		*/
		await addProduct(farm, 'Goddess Melon');
		await addProduct(farm, 'Sugar baby watermelon');
		await addProduct(farm, 'Asparagus');
		console.log('FARM\n' + farm);
	}

	makeFarm();

IN MONGOOSE SHOWS FULL DOCUMENT(BEFORE SAVE)
	FARM
	{
	  name: 'Full Belly Farm',
	  city: 'Guinda, CA',
	  products: [
		{
		  name: 'Goddess Melon',
		  price: 3.5,
		  season: 'Summer',
		  _id: new ObjectId("62cf819abd9538db57f4c4bf"),
		  __v: 0
		},
		{
		  name: 'Sugar baby watermelon',
		  price: 4,
		  season: 'Fall',
		  _id: new ObjectId("62cf819abd9538db57f4c4c0"),
		  __v: 0
		},
		{
		  name: 'Asparagus',
		  price: 9.25,
		  season: 'Spring',
		  _id: new ObjectId("62cf819abd9538db57f4c4c1"),
		  __v: 0
		}
	  ],
	  _id: new ObjectId("62cf88ae735ceca0faca0c6c")
	}

WHEREAS IN DATABASE, STORES OBJECT IDS ALONE(AFTER SAVE)
	db.farms.find({})
	{
		"_id" : ObjectId("62cf88ae735ceca0faca0c6c"),
		"name" : "Full Belly Farm",
		"city" : "Guinda, CA",
		"products" : [ ObjectId("62cf819abd9538db57f4c4bf"), ObjectId("62cf819abd9538db57f4c4c0"), ObjectId("62cf819abd9538db57f4c4c1") ],
		"__v" : 0
	}

POPULATION -> Populated paths are no longer set to their original "_id", their value is replaced with the mongoose document returned from the database

    Farm.findOne({ name: 'Full Belly Farm' }).then((farm) => { console.log('FARM_WO_POPULATE\n' + farm) });

		FARM_WO_POPULATE
		{
		  _id: new ObjectId("62cf88ae735ceca0faca0c6c"),
		  name: 'Full Belly Farm',
		  city: 'Guinda, CA',
		  products: [
			new ObjectId("62cf819abd9538db57f4c4bf"),
			new ObjectId("62cf819abd9538db57f4c4c0"),
			new ObjectId("62cf819abd9538db57f4c4c1")
		  ],
		  __v: 0
		}

    Farm.findOne({ name: 'Full Belly Farm' }).populate('products').then((farm) => { console.log('FARM_WITH_POPULATE\n' + farm) });

		FARM_WITH_POPULATE
		{
		  _id: new ObjectId("62cf88ae735ceca0faca0c6c"),
		  name: 'Full Belly Farm',
		  city: 'Guinda, CA',
		  products: [
			{
			  _id: new ObjectId("62cf819abd9538db57f4c4bf"),
			  name: 'Goddess Melon',
			  price: 3.5,
			  season: 'Summer',
			  __v: 0
			},
			{
			  _id: new ObjectId("62cf819abd9538db57f4c4c0"),
			  name: 'Sugar baby watermelon',
			  price: 4,
			  season: 'Fall',
			  __v: 0
			},
			{
			  _id: new ObjectId("62cf819abd9538db57f4c4c1"),
			  name: 'Asparagus',
			  price: 9.25,
			  season: 'Spring',
			  __v: 0
			}
		  ],
		  __v: 0
		}

ONE TO BAJILLIONS
---
WITH THOUSANDS OR MORE DOCUMENTS, IT'S MORE EFFICIENT TO STORE A REFERENCE TO THE PARENT ON THE CHILD DOCUMENT

When we have a large volume of data, it is often more efficient to actually store a reference to the parent on the child,
rather than storing a reference to the child on a parent like a list of IDs
For example. we can store a reference to the user on an individual tweet

	const mongoose = require('mongoose');

	mongoose.connect('mongodb://localhost:27017/relationshipDemo', { useNewUrlParser: true })
		.then(() => {
			console.log('MONGO CONNECTION OPEN!');
		})
		.catch(() => {
			console.log('OOPS..MONGO CONNECTION ERROR!');
			console.log(err);
		});

	const userSchema = new mongoose.Schema({
		name: String,
		age: Number
	});

	const tweetSchema = new mongoose.Schema({
		text: String,
		likes: Number,
		user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
	});

	const User = mongoose.model('User', userSchema);
	const Tweet = mongoose.model('Tweet', tweetSchema);

	const makeTweets = async () => {
		//const user = new User({ name: 'Vijay', age: 40 });
		const user = await User.findOne({ name: 'Vijay', age: 40 });
		const tweet1 = new Tweet({ text: 'Work is also essential!', likes: 12341 });
		tweet1.user = user;
		//user.save();
		tweet1.save();
	}

	const findTweets = async () => {
		const tweet = await Tweet.findOne({ text: 'Sleep is essential!' }).populate('user');
		console.log(tweet);
	}

	findTweets();
	//makeTweets();

	OUTPUT
	------
	{
	  _id: new ObjectId("62d0e16058591ca16b6a843a"),
	  text: 'Sleep is essential!',
	  likes: 2,
	  user: {
		_id: new ObjectId("62d0e16058591ca16b6a8439"),
		name: 'Vijay',
		age: 40,
		__v: 0
	  },
	  __v: 0
	}

FIELD SELECTION
	What if we want a few specific fields returned from the populated documents? This can be acheived by passing the
	usual field name syntax as the second argument to the populate method

	const findTweets = async () => {
		const tweet = await Tweet.findOne({ text: 'Sleep is essential!' }).populate('user', 'name');
		console.log(tweet);
	}

	OUTPUT:
	{
	  _id: new ObjectId("62d0e16058591ca16b6a843a"),
	  text: 'Sleep is essential!',
	  likes: 2,
	  user: { _id: new ObjectId("62d0e16058591ca16b6a8439"), name: 'Vijay' },
	  __v: 0
	}

MONGO SCHEMA DESIGN
---
https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-3

Denormalize - Have some duplicate information so that we could store some data on both sides if it makes sense in our application

Rules of Thumb:

One: favor embedding unless there is a compelling reason not to

Two: needing to access an object on its own is a compelling reason not to embed it

Three: Arrays should not grow without bound. If there are more than a couple of hundred documents on the “many” side, don’t embed them;
if there are more than a few thousand documents on the “many” side, don’t use an array of ObjectID references.
High-cardinality arrays are a compelling reason not to embed.

Four: Don’t be afraid of application-level joins: if you index correctly and use the projection specifier (as shown in part 2)
then application-level joins are barely more expensive than server-side joins in a relational database.

Five: Consider the write/read ratio when denormalizing. A field that will mostly be read and only seldom updated is a good candidate for denormalization:
if you denormalize a field that is updated frequently then the extra work of finding and updating all the instances is likely to overwhelm the savings
that you get from denormalizing.

Six: As always with MongoDB, how you model your data depends – entirely – on your particular application’s data access patterns.
You want to structure your data to match the ways that your application queries and updates it.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MONGO RELATIONSHIPS WITH EXPRESS
++++++++++++++++++++++++++++++
DEFINING FARM AND PRODUCT MODELS
CREATING FARMS
FARMS SHOW PAGE
DELETING WITH MONGO MIDDLEWARE

NESTED ROUTING
---
More than one dynamic variable in the path that you may want to draw from instead of the route callbacks, the route handlers
i.e. instead of /products/:product_id use the /farms/:farm_id/products/:product_id

DELETING WITH MONGO MIDDLEWARE
---
NOTE: Mongoose Middleware are entirely different from Express Middleware
Mongoose has 4 types of middleware : Document middleware, Model middleware, Aggregate middleware, Query middleware


Model.findByIdAndDelete() -> This function triggers the findOneAndDelete() middleware
This can be acheived by setting up a middleware on the Model schema(before we compile the actual model)

In the Pre middleware, we dont have access to the data that is getting deleted
In the Post middleware, we do have access to the data that is getting deleted

farmSchema.pre('findOneAndDelete', async function(data){
    console.log('PRE is invoked');
    console.log(data);
});

farmSchema.post('findOneAndDelete', async function(farm){
    console.log('POST is invoked');
    if(farm.products.length){
        const res = await Product.deleteMany({_id:{$in:farm.products}});
        console.log(res);
    }
});

PULL OPERATOR
---
The $pull removes from an existing array all instances of a value or values that match a specified condition
The pull operator has the form
{ $pull : { <field1> : <value|condition>, <field2> : <value|condition>, ..}}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
EXPRESS ROUTER AND COOKIES
++++++++++++++++++++++++++++++
EXPRESS ROUTER BASICS
UNDERSTANDING COOKIES
HMAC SIGNING
SIGNED COOKIES
COOKIE PARSER

EXPRESS ROUTER
---
Way of breaking out Routes into separate files/objects, grouping them together
A Router object is an isolated instance of middleware and routes.
Mini application capable of performing middleware and routing functions
Every express application has a built-in app router

express.Router([options]) -> Creates a new Router object

var router = express.Router([options])
where options -> mergeParams, caseSensitive, strict

We can also add in our own middleware that will only apply to a specific set of routes

index.js
++++++++
		const express = require('express');
		const app = express();
		const dogRoutes = require('./routes/dogs');
		const catRoutes = require('./routes/cats');
		const adminRoutes = require('./routes/admin');

		app.use((req, res, next) => {						-> Applying Middleware Generically
		    if (req.query.isAdmin) {
		        next();
		    }
		    res.send('Sorry! Not an Admin :(');
		});
		app.use('/dog', dogRoutes);
		app.use('/cat', catRoutes);
		app.use('/admin', adminRoutes);

		app.listen(3000, () => {
		    console.log('Serving app on localhost 3000');
		});

dogs.js
+++++++
		const express = require('express');
		const router = express.Router();

		router.get('/', (req, res) => { res.send("ALL DOGS"); });
		router.post('/', (req, res) => { res.send("CREATING DOG"); });
		router.get('/:id', (req, res) => { res.send("VIEWING ONE DOG"); });
		router.get('/:id/edit', (req, res) => { res.send("EDITING ONE DOG"); });

		module.exports = router;

http://localhost:3000/dog/sf?isAdmin=true

admin.js
++++++++
const express = require('express');
const router = express.Router();

router.use((req, res, next) => {						-> Applying Middleware pertaining to a specific route
    if (req.query.isAdmin) {
        next();
    }
    res.send('Sorry! Not an Admin :(');
});

router.get('/topsecret', (req, res) => { res.send("THIS IS TOP SECRET!"); });
router.post('/deleteall', (req, res) => { res.send("DELETING EVERYTHING"); });

module.exports = router;

http://localhost:3000/admin/topsecret?isAdmin=true

UNDERSTANDING COOKIES
----
Cookies are little bits of information that are stored in a user's browser when browsing a particular website
Once a cookie is set, a user's browser will send the cookie on every subsequent request to the site
Cookies allow use to make HTTP stateful

app.get('/setname', (req,res) => {
    res.cookie('name', 'Vijay');
    res.send('COOKIE SET!');
});


Cookie-Parser
	Parse cookie header and populate req.cookies with an object keyed by the cookie names
	Optionally you may enable signed cookie support by passing in a secret string, which
	assigns request.secret so it may be used by other middleware

	npm install cookie-parser

	const express = require('express');
	const cookieParser = require('cookie-parser');
	const app = express();
	app.use(cookieParser());

	app.get('/greet', (req, res) => {
	    const {name = 'There'} = req.cookies;
	    res.send(`Hey ${name}!`);
	});

	app.get('/setname', (req,res) => {
	    res.cookie('name', 'Vijay');
	    res.send('COOKIE SET!');
	});

SIGNED COOKIES
---
Objective is to verify its integrity. i.e. Verify that something hasn't changed
Have cookie parser sign it using a secret code and send it to the browser
Later the cookie parser verifies whether any of those signed cookies has been tampered or not

req.signedCookies
When using cookie-parser middlelware, this property contains signed cookies sent by the request, unsigned and ready for use
Signed cookies reside in a different object to show developer intent. Otherwise a malicious attack could be placed on
req.cookie values(which are easy to spoof)
Note that signing a cookie doesn't make it hidden or encrypted, but simply prevents tampering, because the secret used to
sign is private

console.dir(req.signedCookies.user)

	app.use(cookieParser('MySecretCode'));

	app.get('/setSignedCookie', (req, res) => {
	    res.cookie('fruit', 'grape', { signed: true })
	    res.send('SIGNED COOKIE SET!');
	});

	app.get('/verifySignedCookie', (req, res) => {
	    const { fruit = 'no fruit' } = req.signedCookies;
	    res.send(`I ate ${fruit} today!`);
	});


I ate grape today! -> If Signed
I ate no fruit today! -> If not signed
I ate false today! -> I signed and cookie value is tampered

HMAC - Hash Based Message Authentication Code
The Same Secret Key and the same value are going to work when we receive it back
